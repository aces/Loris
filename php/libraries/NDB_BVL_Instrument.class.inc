<?php
/**
 * This file contains the base class for instruments in Loris
 *
 * PHP Version 7
 *
 * @category Main
 * @package  Behavioural
 * @author   Loris team <info-loris.mni@mcgill.ca>
 * @license  http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link     https://www.github.com/aces/Loris-Trunk/
 */

/**
 * Base class for all NeuroDB behavioural instruments
 *
 * Throws PEAR errors. Also requires PEAR HTML_Quickform.
 *
 * @category Main
 * @package  Behavioural
 * @author   Loris team <info-loris.mni@mcgill.ca>
 * @license  http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link     https://www.github.com/aces/Loris-Trunk/
 */
abstract class NDB_BVL_Instrument extends NDB_Page
{

    /**
     * Determines whether this instrument should load data in
     * JSON format from the "Data" column of the flag table, or
     * from the traditional SQL tables.
     */
    protected $jsonData = false;

    /**
     * HTML_Quickform object
     *
     * @access private
     */
    var $form;

    /**
     * Test name (short name), equivalent to test_names.Test_name
     *
     * @access private
     */
    var $testName;

    /**
     * Instrument instance CommentID
     *
     * @access private
     */
    var $commentID;

    /**
     * Database table containing data referenced by $this->commentID
     *
     * @access private
     */
    var $table;

    /**
     * Cache location for the date of administration
     *
     * @access private
     */
    var $dateOfAdministration;

    /**
     * Additional form defaults - should only be used for lorisform
     * static elements!
     *
     * @access private
     */
    var $localDefaults = array('emptyCell' => '&nbsp;');

    /**
     * String to separate the group elements
     *
     * @access private
     */
    var $_GUIDelimiter = "</td>\n<td>";

    /**
     * Commonly used level of indentation
     *
     * @access private
     */
    var $indent = "&nbsp;&nbsp;&nbsp;&nbsp;";

    /**
     * Array of required fields to check
     *
     * @access private
     */
    var $_requiredElements = array();

    /**
     * Array of date fields to be processed into QuickForm dates
     * NOTE: When abstracting the _saveValues() method in the child <instrument>
     * class, add only the dates from the current page to the array using the
     * instruments switch($page) otherwise you'll end up overwriting (NULLing)
     * all other dates in the table that appear on other pages (if they are
     * listed in the array of date fields) - note by Dario
     */
    var $dateTimeFields = array();

    /**
     * Array of date fields that contain only month year fields in frontend with
     * a static value for the date
     */
    var $monthYearFields = array();
    /**
     * Array of column names to be ignored by the double data entry conflict
     * detector.
     */
    var $_doubleDataEntryDiffIgnoreColumns
        = array(
           'CommentID',
           'UserID',
           'Testdate',
           'Window_Difference',
           'Candidate_Age',
           'Data_entry_completion_status',
          );

    /**
     * Whether the "Validity" field is shown as a flag for an instrument
     * or not.
     *
     * @access private
     */
    var $ValidityEnabled = true;

    /**
     * Whether the "Validity" field is required before flagging an instrument
     * as complete or not.
     *
     * @access private
     */
    var $ValidityRequired = true;

    /**
     * True if the instrument page is being loaded by a script
     * such as the lorisform_parser where all elements should be added to form,
     * ignoring age-dependent or other conditional display logic in the form.
     * To be called from within individual instrument forms.
     */
    var $displayAllFields = false;

    var $WrapperTextElements           = array();
    var $WrapperNumericElements        = array();
    var $WrapperDateWithStatusElements = array();

    /**
     * True if the page is being previewed from the instrument builder,
     * and not really loaded. only applies to LINST instrument.
     */
    public $preview = false;

    /**
     * Factory generates a new instrument instance of type
     * $instrument, and runs the setup() method on that new
     * instrument.
     *
     * @param string  $instrument       The name of the instrument to use
     * @param string  $commentID        The CommentID identifying the data to load
     *                                  load
     * @param string  $page             If a multipage form, the page to show
     * @param boolean $guarantee_exists If true the factory will throw an
     *                                  error if the file does not exist, otherwise
     *                                  will silently return if the instrument is
     *                                  missing.
     *
     * @return object|null the new object of $instrument type
     * @access public
     */
    static function factory(
        string $instrument,
        string $commentID = '',
        string $page = '',
        bool $guarantee_exists = true
    ) {
        $class = "NDB_BVL_Instrument_$instrument";

        // Make sure the instrument class has been included/required!
        $factory = NDB_Factory::singleton();
        $config  = $factory->config();
        $base    = $config->getSetting('base');

        // The conflict resolver doesn't care if the instrument exists or not, it
        // just tries to load, score, and save. If it doesn't exist, for instance
        // in the case of figs_year3_relatives, we shouldn't require because it
        // isn't necessarily an error.
        if (!file_exists($base."project/instruments/$class.class.inc")
            && !file_exists($base."project/instruments/$instrument.linst")
            && $guarantee_exists==false
        ) {
            return null;
        }
        if (file_exists($base."project/instruments/$instrument.linst")
        ) {
            include_once 'NDB_BVL_Instrument_LINST.class.inc';
            $obj = new \Loris\Behavioural\NDB_BVL_Instrument_LINST(
                // The module directory we use for instruments is arbitrary,
                // since it isn't a real module, but it's required for the page
                // constructor.
                new Module($instrument, $base ."project/"),
                $page,
                $commentID,
                $commentID,
                'test_form'
            );
        } else {
            if (!class_exists($class)
                && ($guarantee_exists === true
                && !file_exists($base."project/instruments/$class.class.inc"))
            ) {
                throw new Exception("Instrument does not exist");
            }
            if (!class_exists($class)) {
                include_once $base."project/instruments/$class.class.inc";
            }
            // Now go ahead and instantiate it
            $obj = new $class(
                new Module($instrument, $base ."project/"),
                $page,
                $commentID,
                $commentID,
                'test_form'
            );
        }

        // if a script is loading this form without a commentID, display all fields
        if (!isset($commentID)) {
            $obj->displayAllFields = true;
        }

        // Sets up page variables such as $this->commentID and $this->form
        $obj->setup($commentID, $page);

        if (!empty($commentID)) {
            $obj->setupCandidateInfoTables();
        }
        // Adds all of the form element and form rules to the page after
        // having instantiated the form above
        $obj->loadInstrumentFile(
            $base . "project/instruments/$instrument.linst"
        );
        // Add rules only if they exist.
        if (file_exists($base."project/instruments/$instrument.rules")) {
            $obj->loadInstrumentRules(
                $base . "project/instruments/$instrument.rules"
            );
        }

        $user   = \User::singleton();
        $access = $obj->_hasAccess($user);

        // check that user has access
        if ($access == false) {
            throw new Exception(
                "You do not have access to this page.",
                403
            );
        }

        return $obj;
    }


    /**
     * Checks if the user has permissions to view the instrument.
     *
     * Relies on <instrumentPermissions> settings in the config.xml file.
     *
     * This follows a permissive scheme.
     * If the instrument is not listed in the instrumentPermissions section,
     * access is granted.
     * If the user has ANY of the permissions listed in the config.xml file for
     * the instrument, access is granted.
     *
     * @param \User $user The user whose access is being checked
     *
     * @return bool
     */
    function _hasAccess(\User $user) : bool
    {
        //get config
        $config = \NDB_Config::singleton();
        $instrumentPermissions = $config->getSetting("instrumentPermissions");

        //check if instrumentPermissions are being used.
        if (!is_array($instrumentPermissions)) {
            //instrument permissions not used...
            return true; //default
        } else if (!array_key_exists(
            'useInstrumentPermissions',
            $instrumentPermissions
        )
        ) {
            //instrument permissions not used...
            return true; //default
        } else if ($instrumentPermissions['useInstrumentPermissions'] == 'false') {
            //instrument permissions not used...
            return true; //default
        } else { //check if user has instrument's permissions
            //is the instrument listed at all in instrumentPermissions?
            $instrumentListed = false;
            foreach ($instrumentPermissions["instrument"] as $instrument) {
                if ($instrument["Test_name"] == $this->testName) {
                    $instrumentListed = true;
                    $instrumentPerms  = Utility::asArray($instrument["permission"]);
                }
            }

            //no permissions defined
            if (!$instrumentListed) {
                return true;
            }

            //check if user possesses ANY of the required permissions
            foreach ($instrumentPerms as $instrumentPerm) {
                if ($user->hasPermission($instrumentPerm)) {
                    return true;
                }
            }

            //no user permissions match required instrument permissions
            throw new Exception("You do not have access to this page.", 403);
        }
    }

    /**
     * Sets up basic data, such as the HTML_Quickform object, and so on.
     *
     * @param string|null $commentID The CommentID identifying the data to load
     * @param string|null $page      If a multipage form, the page to show
     *
     * @return   void
     * @access   public
     * @abstract
     */
    function setup(?string $commentID = null, ?string $page = null): void
    {
        $this->commentID = $commentID;
        $this->page      = $page;
    }

    /**
     * Gets data for candidate and timepoint to display the tables at the top of the
     * page. This info is then set in the tpl_data array.
     *
     * @return void
     */
    function setupCandidateInfoTables(): void
    {
        try {
            $timePoint = \TimePoint::singleton($this->getSessionID());
        } catch (Exception $e) {
            throw new LorisException($e->getMessage());
        }

        try {
            $candidate = \Candidate::singleton($timePoint->getCandID());
        } catch(Exception $e) {
            throw new LorisException($e->getMessage());
        }

        $this->tpl_data['candidate'] = $candidate->getData();
        $this->tpl_data['timePoint'] = $timePoint->getData();
    }

    /**
     * Method to compute scores - by default will run a script named
     * after the testName in the instrument directory if it exists,
     * but any instrument with a scoring algorithm to implement can override
     * it in PHP.
     *
     * @return void
     * @access public
     */
    function score(): void
    {
        $config = NDB_Config::singleton();
        $base   = $config->getSetting('base');
        $scorer = $base . "project/instruments/" . $this->testName . ".score";

        if (file_exists($scorer)) {
            $output = array();
            exec(
                $scorer . " " . escapeshellarg($this->getCommentID()),
                $output,
                $retVal
            );
            if ($retVal != 0) {
                print "Error running scoring algorithm";
            }
        }
    }



    /**
     * Method to display the form for an instrument
     *
     * @return string
     * @access public
     */
    function display(): string
    {
        // ALWAYS INCLUDE THESE!

        if (isset($_REQUEST['key'])) {
            $this->DataEntryType = 'DirectEntry';
        } else {
            $this->DataEntryType = 'normal';
            // These are required for Save Data to work properly, but not when it's
            // a direct data entry page
            $this->addHidden(
                'candID',
                isset($_REQUEST["candID"]) ? $_REQUEST['candID'] : ''
            );
            $this->addHidden(
                'sessionID',
                isset($_REQUEST["sessionID"]) ? $_REQUEST['sessionID'] : ''
            );
        }
        $this->addHidden('commentID', $this->getCommentID());
        $this->addHidden('test_name', $this->testName);
        $this->addHidden('page', $this->page);
        $this->addHidden('subtest', $this->page);

        // Don't show save button for Direct Data entry type,
        // because that's part of the DirectEntry template
        // and has Save/Continue and go back buttons
        if (!$this->form->isFrozen() && $this->DataEntryType === 'normal') {
            $buttons[] = $this->form->createElement(
                'submit',
                'fire_away',
                'Save Data',
                array('class' => 'button')
            );
            //$buttons[] = $this->form->createElement('reset', null, 'Reset');
            $this->addGroup($buttons, null, null, "&nbsp;");
        }

        $defaults = $this->loadInstanceData($this);

        // set the defaults (call private method _setDefaultsArray
        // which could be overridden if necessary)
        $defaults = $this->_setDefaultsArray($defaults ?? array());

        // merge in the localDefaults property so that simple
        // additions to the defaults array no longer requires
        // overriding the _setDefaultsArray method
        $defaults = array_merge($defaults, $this->localDefaults);

        $this->form->setDefaults($defaults);

        if ($this->DataEntryType == 'DirectEntry') {
            $smarty = new Smarty_neurodb;

            $formArray = $this->form->toElementArray();
            if (isset($this->testName)) {
                $formArray['tableID'] = "instrument_$this->testName";
            } else {
                $formArray['tableID'] = "instrument";
            }

            $smarty->assign('form', $formArray);
            $html = $smarty->fetch("directentry_form.tpl");
        } elseif (isset($_REQUEST['json']) == 'true') {
            // Mostly here for debugging. Realisticly, the JSON
            // representation will be retrieved through the API,
            // not the display function.
            return $this->toJSON();
        } else {
            $smarty    = new Smarty_neurodb;
            $formArray = $this->form->toElementArray();

            $smarty->assign('form', $formArray);
            $smarty->assign($this->tpl_data);
            $html = $smarty->fetch("instrument_html.tpl");
        }

        return $html;
    }

    /**
     * Accepts an array usable as input to HTML_Quickform::setDefaults()
     * and does any necessary preprocessing on that array.
     *
     * @param array $defaults the array to be passed on to
     *                        HTML_Quickform::setDefaults()
     *
     * @return array the processed array ready for setDefaults()
     * @access private
     */
    function _setDefaultsArray(array $defaults): array
    {
        //Convert date/time fields into lorisform date/timestamps
        if (empty($this->dateTimeFields)) {
            $this->dateTimeFields = array("Date_taken");
        }

        if (isset($defaults['Window_Difference'])
            && $defaults['Window_Difference'] != 0
        ) {
            $defaults['Candidate_Age']
                = $defaults['Candidate_Age'] . " (Age out of range)";
        }
        //Convert select multiple elements into a lorisform array
        if (!empty($this->_selectMultipleElements)) {
            foreach ($this->_selectMultipleElements AS $elname) {
                if (isset($defaults[$elname])
                    && stristr($defaults[$elname], "{@}")
                ) {
                    $defaults[$elname] = explode("{@}", $defaults[$elname]);
                }
            }
        }

        // return the defaults array ready for $form->setDefaults
        return $defaults;
    }

    /**
     * Attempts to validate the form (using the defined rules) and
     * saves the validated data into the database
     *
     * @return bool false if failure to save data
     * @access public
     */
    function save(): bool
    {
        if ($this->form->validate()) {
            $this->form->process(array(&$this, '_saveValues'), true);
            $this->score();

            // determine the data entry completion status, and store that in
            // the database
            $dataEntryCompletionStatus
                = $this->_determineDataEntryCompletionStatus();
            $this->_setDataEntryCompletionStatus(
                $dataEntryCompletionStatus
            );
        } else {
            $submittedData = $this->form->getSubmitValues();

            if (count($submittedData)) {

                // the form WAS submitted but validate() failed...
                // main error message
                $this->form->addElement('static', 'mainError');
                $this->form->setElementError(
                    'mainError',
                    "<p>
                    <font color='red'>
                        A data entry error has been detected so this data
                        <b>WAS NOT SAVED</b>
                    </font>
                    </p>\n"
                );
                //print all the field error messages in one block
                foreach (array_keys($submittedData) AS $key) {
                    $error = $this->form->getElementError($key);
                    if (!empty($error)) {
                        // FIXME: Why is this here? The body of this if
                        // statement does nothing.. -- Dave
                        $element = $this->form->getElement($key);
                        if (method_exists($element, "getLabel")) {
                            // print "<font color='red'>"
                            // .$element->getLabel()
                            // .": $error</font><br>\n";
                        }
                    }
                }
                return false;
            }
        }

        return true;
    }

    /**
     * This handles the saving of the Candidate_Age and Window_Difference columns
     * to the database when the save function is called with a Date_taken.
     *
     * @param array $values A reference to the values saved from QuickForm that
     *                      will be passed to update. This will be modified to
     *                      have Candidate_Age and Window_Difference if the
     *                      Date_taken field is included.
     *
     * @return void (but as a side-effect modifies array that was passed.)
     */
    function _saveCandidateAge(array &$values): void
    {
        if (!empty($values['Date_taken'])) {
            $DB  = Database::singleton();
            $age = $this->getCandidateAge($values['Date_taken']);
            if (empty($age)) {
                throw new LorisException("Candidate age could not be found.");
            }

            $agedays   = $this->calculateAgeDays($age);
            $agemonths = $this->calculateAgeMonths($age);

            if (!empty($age)) {
                $query_params = array(
                                 'TN'  => $this->testName,
                                 'CID' => $this->getCommentID(),
                                );

                $validage = $DB->pselectOne(
                    "SELECT MAX($agedays BETWEEN AgeMinDays AND AgeMaxDays)
                        FROM test_battery tb
                            JOIN flag f USING(Test_name)
                            JOIN session s ON (s.ID=f.SessionID)
                        WHERE tb.Active='Y'
                            AND tb.Test_name=:TN
                            AND tb.SubprojectID=s.SubprojectID
                            AND f.CommentID=:CID",
                    $query_params
                );
                $values['Candidate_Age']     = $agemonths;
                $values['Window_Difference'] = 0;

                // Age isn't valid, so find out how far out it is

                if ($validage == 0) {
                    $Windows = $DB->pselect(
                        "SELECT AgeMinDays, AgeMaxDays
                        FROM test_battery tb
                            JOIN flag f USING(Test_name)
                            JOIN session s ON (s.ID=f.SessionID)
                        WHERE tb.Active='Y' AND tb.Test_name=:TN
                            AND tb.SubprojectID=s.SubprojectID
                            AND f.CommentID=:CID",
                        $query_params
                    );
                    foreach ($Windows as $window) {
                        if ($agedays < $window['AgeMinDays']) {
                            $delta = $window['AgeMinDays'] - $agedays;
                            if (abs($delta) < abs($values['Window_Difference'])
                                || $values['Window_Difference'] == 0
                            ) {
                                $values['Window_Difference'] = 0-abs($delta);
                            }
                        }
                        if ($agedays > $window['AgeMaxDays']) {
                            $delta = $agedays - $window['AgeMaxDays'];
                            if (abs($delta) < abs($values['Window_Difference'])
                                || $values['Window_Difference'] == 0
                            ) {
                                $values['Window_Difference'] = abs($delta);
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Calculate age in months given and array with years months and days
     *
     * @param array $age containing the years, months and days of the age
     *
     * @return float
     */
    function calculateAgeMonths(array $age): float
    {
        $months = $age['year']*12 + $age['mon'] + ($age['day']/30);
        // 1 Decimal.
        $months = (round($months*10) / 10.0);
        return $months;
    }

    /**
     * Calculate age in days given and array with years months and days
     *
     * @param array $age containing the years, months and days of the age
     *
     * @return int
     */
    function calculateAgeDays(array $age): int
    {
        $days = $age['year']*365 + $age['mon']*30 + $age['day'];
        return $days;
    }

    /**
     * This removes all the value of any field which has its accompagning
     * _status field set.
     *
     * @param array $values A reference to the array which will be passed
     *                      to $DB->update().
     *
     * @return void (but as a side-effect modifies &$values array)
     */
    function _nullStatus(array &$values): void
    {
        //Remove the values of all fields who have had statuses assigned
        foreach (array_keys($values) AS $field) {
            if (substr($field, -7)=="_status") {
                if (!empty($values[$field])) {
                    $baseField          = substr($field, 0, (strlen($field)-7));
                    $values[$baseField] = "";
                }
            }
        }
    }

    /**
     * Preprocesses the array of values to be saved into the database
     * (such as to rearrange date fields or process uploaded files)
     *
     * @param array $values the array of values ready to be passed to
     *                      an Database::update call as the set array
     *
     * @return void
     */
    function _saveValues(array $values): void
    {
        //Convet date/timestamps into database format
        if (empty($this->dateTimeFields)) {
            $this->dateTimeFields = array("Date_taken");
        }

        if (strrpos($this->testName, "_proband") === false) {
            $this->_saveCandidateAge($values);
        }

        //Convert select multiple elements into database storable values
        if (!empty($this->_selectMultipleElements)) {
            foreach ($this->_selectMultipleElements AS $elname) {
                if (isset($values[$elname]) && is_array($values[$elname])) {
                    $values[$elname] = implode("{@}", $values[$elname]);
                }
            }
        }

        //XIN specific functionality
        if ($this->formType=="XIN") {
            $this->_nullStatus($values);
        }

        // do not alter this when overwriting the method
        unset(
            $values['candID'],
            $values['sessionID'],
            $values['commentID'],
            $values['test_name'],
            $values['page'],
            $values['fire_away'],
            $values['subtest']
        );
        // nor these -- these ones are for direct data entry
        unset($values['key'], $values['nextpage'], $values['pageNum']);
        $this->_save($values);
    }


    /**
     * Uses the array generated by _saveValues() and runs the
     * Database::update() call.
     *
     * @param array $values the array generated by _saveValues()
     *
     * @return void
     */
    function _save(array $values): void
    {
        $db = Database::singleton();

        // clear any fields starting with __
        foreach (array_keys($values) AS $key) {
            if (strpos($key, '__') === 0) {
                unset($values[$key]);
            }
            $values = Utility::nullifyEmpty($values, $key);
        }
        if ($this->jsonData !== true) {
            // If the instrument is saving as JSON into the Data column, the
            // table may not exist, so don't try and update it.
            $db->update(
                $this->table,
                $values,
                array('CommentID' => $this->getCommentID())
            );
        }

        // Extract the old data and merge it with what was submitted so that we
        // don't overwrite data from other pages.
        $oldData = $db->pselectOne(
            "SELECT Data FROM flag WHERE CommentID=:cid",
            array('cid' => $this->getCommentID())
        );

        // (The PDO driver seems to return null as "null" for JSON column types)
        if (!empty($oldData) && $oldData !== "null") {
            $oldData = json_decode($oldData, true);
        } else {
            $oldData = array();
        }
        $newData = array_merge($oldData ?? array(), $values);

        // Save the JSON to the flag.Data column.
        //
        // json_encode ensures that this is safe. If we use the safe wrapper,
        // HTML encoding the quotation marks will make it invalid JSON.
        $db->unsafeUpdate(
            "flag",
            array("Data" => json_encode($newData)),
            array('CommentID' => $this->getCommentID())
        );

    }


    /**
     * Adds metadata fields (such as Examiner and Date_taken) to the
     * current form
     *
     * @return void
     * @access private
     */
    function _addMetadataFields(): void
    {
        $config      = \NDB_Config::singleton();
        $dateOptions = array(
                        'language'         => 'en',
                        'format'           => 'YMd',
                        'minYear'          => $config->getSetting('startYear'),
                        'maxYear'          => $config->getSetting('endYear'),
                        'addEmptyOption'   => true,
                        'emptyOptionValue' => null,
                       );

        $this->dateOptions = $dateOptions;

        $this->addBasicDate('Date_taken', 'Date of Administration', $dateOptions);

        if (strrpos($this->testName, '_proband') === false) {
            $this->addScoreColumn(
                'Candidate_Age',
                'Candidate Age (Months)'
            );
            $this->addScoreColumn(
                'Window_Difference',
                'Window Difference (+/- Days)'
            );
        }
        $examiners = $this->_getExaminerNames();
        $this->addSelect('Examiner', 'Examiner', $examiners);

        $this->addRule(
            'Date_taken',
            'Date of Administration is required',
            'required'
        );

        $this->addRule('Examiner', 'Examiner is required', 'required');
    }

    /**
     * Process the Config file. This results in:
     *     1. $CertificationEnabled being true or false,
     *     2. $CertificationProjects being a list of projects which
     *        use ceritification and,
     *     3. $CertificationInstruments being a list of instruments
     *        that use certification.
     * This is put in a different function so that instruments that
     * override getExaminerNames() can still easily get the config
     * settings and don't need to parse the config file themselves.
     *
     * @return array
     */
    function _getCertificationConfig(): array
    {
        $config = \NDB_Config::singleton();

        $CertificationConfig      = $config->getSetting("Certification");
        $CertificationEnabled     = $CertificationConfig['EnableCertification'];
        $CertificationProjects    = array();
        $CertificationInstruments = array();

        if ($CertificationEnabled) {
            foreach (
                Utility::associativeToNumericArray(
                    $CertificationConfig['CertificationProjects']
                )
                as $value
            ) {
                if (is_array($value['CertificationProject'])) {
                    $value = $value['CertificationProject'];
                }
                foreach ($value as $projID) {
                    $CertificationProjects[$projID] = $projID;
                }
            }
            foreach (
                Utility::associativeToNumericArray(
                    $CertificationConfig['CertificationInstruments']
                )
                as $instrument
            ) {
                foreach (
                    Utility::associativeToNumericArray($instrument['test'])
                    as $test
                ) {
                    $CertificationInstruments[] = $test['@']['value'];
                }
            }
        }
        return array(
                $CertificationEnabled,
                $CertificationProjects,
                $CertificationInstruments,
               );
    }


    /**
     * Gets the list of examiners for the site of the current instrument
     *
     * @return array
     */
    function _getExaminerNames(): array
    {
        $db = \Database::singleton();

        $centerID = $db->pselectOne(
            "SELECT session.CenterID FROM session, flag
            WHERE session.ID=flag.SessionID AND flag.CommentID=:cmnt_id",
            array('cmnt_id' => $this->getCommentID())
        );
        if (is_array($centerID)) {
            $centerID = null;
        }

        //get examiner certifications for profiles part of IBIS2
        $candID  = isset($_REQUEST['candID']) ? $_REQUEST['candID'] : '';
        $project = $db->pselectOne(
            "SELECT ProjectID from candidate where CandID =:cnd_id",
            array('cnd_id' => $candID)
        );

        list(
            $CertificationEnabled,
            $CertificationProjects,
            $CertificationInstruments
            ) = $this->_getCertificationConfig();
        if ($CertificationEnabled && in_array($project, $CertificationProjects)
            && in_array($this->testName, $CertificationInstruments)
        ) {
            $test_id = $db->pselectOne(
                "SELECT ID FROM test_names WHERE Test_name=:tst_name",
                array('tst_name' => $this->testName)
            );
            $results = $db->pselect(
                "SELECT c.examinerID, e.full_name
                 FROM certification c
                     JOIN examiners e
                         ON (c.examinerID = e.examinerID)
                     JOIN examiners_psc_rel epr
                         ON (epr.examinerID=e.examinerID)
                 WHERE c.testID =:tid
                    AND c.pass =:cert_id
                    AND epr.centerID =:cid
                 ORDER BY full_name",
                array(
                 'tid'     => $test_id,
                 'cert_id' => 'certified',
                 'cid'     => $centerID,
                )
            );
        } else {
            $results = $db->pselect(
                "SELECT e.examinerID, e.full_name
                     FROM examiners e
                         JOIN examiners_psc_rel epr
                             ON (epr.examinerID=e.examinerID)
                 WHERE epr.centerID=:centID
                     ORDER BY full_name",
                array('centID' => $centerID)
            );
        }

        $examiners = array('' => '');
        if (is_array($results) && !empty($results)) {
            foreach ($results AS $row) {
                $examiners[$row['examinerID']] = $row['full_name'];
            }
        }
        return $examiners;
    }


    /**
     * Return the full, human readable name for the
     * current instrument.
     *
     * @return string the full name of the instrument
     */
    abstract public function getFullName(): string;

    /**
     * Gets the current object instance CommentID
     *
     * @return string|null          the CommentID of this instrument.
     * @access public
     */
    function getCommentID(): ?string
    {
        return $this->commentID;
    }


    /**
     * Freezes the current form
     *
     * @return void
     * @access public
     */
    function freeze(): void
    {
        if (isset($_REQUEST['json']) && $_REQUEST['json'] === 'true') {
            return;
        }
        $this->form->freeze();
    }


    /**
     * Gets the date of administration of an instrument instance.
     * Caches to reduce DB hits
     *
     * @return mixed $dateOfAdministration the date of administration from
     *         the DB, in the format "YYYY-MM-DD"
     */
    function getDateOfAdministration()
    {
        $db  = \Database::singleton();
        $doa = $db->pselectOne(
            "SELECT Date_taken FROM $this->table WHERE CommentID=:CID",
            array('CID' => $this->getCommentID())
        );
        $this->dateOfAdministration = $doa;

        return $this->dateOfAdministration;
    }


    /**
     * Returns a list of subtests of the current instrument.
     * The returned array should be a list of rows where each
     * row has a key for "Name" (the subpage name) and "Description"
     * (the human readable name)
     *
     * @return array
     */
    abstract function getSubtestList(): array;

    /**
     * Marks an element in the lorisform object as being required (for
     * use with the requiredIf rule)
     *
     * @param string $elementName the element to add to the required list
     *
     * @return void
     */
    function setRequired(string $elementName): void
    {
        if (!in_array($elementName, $this->form->_required)) {
            $this->form->_required[] = $elementName;
        }
    }


    /**
     * Convert a lorisform date or timestamp into a database acceptable
     * (and storable) date or time
     *
     * @param array $formDateValue the lorisform date/timestamp array
     *
     * @return string the date or timestamp from the database
     * @access private
     */
    function _getDatabaseDate(array $formDateValue): string
    {
        if (!empty($formDateValue)) {

            $databaseValue = "";

            if (array_key_exists("Y", $formDateValue)
                || array_key_exists("M", $formDateValue)
                || array_key_exists("d", $formDateValue)
            ) {

                if (array_key_exists("Y", $formDateValue)) {
                    $yearString = $formDateValue['Y'];
                } else {
                    $yearString = "0001";
                }

                if (array_key_exists("M", $formDateValue)) {
                    $monthString = $formDateValue['M'];
                } else {
                    $monthString = "01";
                }

                if (array_key_exists("d", $formDateValue)) {
                    $dayString = $formDateValue['d'];
                } else {
                    $dayString = "01";
                }

                $databaseValue = $yearString . "-" . $monthString . "-" . $dayString;

            } elseif (array_key_exists("H", $formDateValue)
                || array_key_exists("i", $formDateValue)
            ) {
                if (array_key_exists("H", $formDateValue)) {
                    $hourString = $formDateValue['H'];
                } else {
                    $hourString = "01";
                }
                if (array_key_exists("i", $formDateValue)) {
                    $minuteString = $formDateValue['i'];
                } else {
                    $minuteString = "01";
                }

                $databaseValue = $hourString . ":" . $minuteString;

            }
        }
        return $databaseValue;
    }


    /**
     * Convert a database date or timestamp into a QuickForm acceptable date or time
     *
     * @param string $databaseValue the date or timestamp from the database
     *
     * @return array the lorisform date/timestamp array
     */
    function _getQuickformDate(string $databaseValue)
    {
        throw new Exception(
            "The function _getQuickformDate has been deprecated. 
            Please contact LORIS developer mail list for support."
        );
    }


    /**
     * This runs the XIN rules on all the elements on the current page to ensure
     * that no rules were violated.
     *
     * @param array $elements The value of all the elements on the current page
     *                        to validate.
     *
     * @return array|true associative array of errors (fieldname => errormessage)
     *         or true if no errors.
     */
    function XINValidate(array $elements)
    {
        unset($elements['key'], $elements['pageNum'], $elements['nextpage']);
        $this->XINDebug = false;  //Turn this on to see rules debuggin output

        $errors = array();
        foreach ($elements AS $elname => $elvalue) {
            //If the element is a group (and thus elvalue is an array)
            //trigger the Null Value default rule if ANY of the values
            //in the group are empty.
            $flag = true;
            if (is_array($elvalue)) {
                foreach ($elvalue AS $val) {
                    if ($val === "") {
                        $flag = false;
                    }
                }
            }

            //If the answer is empty (or its a group and one of answers in the
            //group is empty) then run the rules
            if ($elvalue==="" || $flag==false) {
                if ($this->XINDebug) {
                    //debugging code
                    echo "<p><b>$elname</b><br> ";
                }
                if (!empty($this->XINRules[$elname])) {
                    $result = $this->XINRunElementRules(
                        $elname,
                        $elements,
                        $this->XINRules[$elname]
                    );
                    if (is_array($result)) {
                        $errors += $result;
                    }
                } else if (substr($elname, -7) != "_status"
                    && !in_array($elname, array("page", "subtest"))
                ) {
                    $errors[$elname] = "Required.";
                    if ($this->XINDebug) {
                        echo "Required by default";
                    }
                } else {
                    if ($this->XINDebug) {
                        echo "Status' not required by default";
                    }
                }
            }
        }

        if (!empty($errors)) {
            return $errors;
        }
        return true;
    }

    /**
     * Attaches a user defined rule (conditions) to a form element (grouped or not).
     *
     * @param string $elname  Name of element registering the rule
     * @param array  $rules   Array of rules to apply in an AND fashion.
     *                        Rules are written in rose ({@}) format
     *                        (ie. array('q_8{@}=={@}1_yes','q_8_a_status{@}=={@}').
     *                        ORs may be written within the same array value.
     * @param string $message Message to print upon rule violation
     * @param string $group   Empty if a non-grouped element is registering the rule.
     *                        Otherwise, name of the group registering the rule.
     *
     * @return bool
     */
    function XINRegisterRule(
        string $elname,
        array $rules,
        string $message="",
        string $group=""
    ): bool {
        if (!is_array($rules)) {
            $rules_array[] = $rules;
        } else {
            $rules_array = $rules;
        }
        $this->XINRules[$elname]['message'] = $message;
        $this->XINRules[$elname]['group']   = $group;

        foreach ($rules_array AS $rule) {
            $this->XINRules[$elname]['rules'][] = $rule;
        }
        return true;
    }


    /**
     * Run XIN rules on element
     *
     * Run the rules and see if the required flag need be raised.
     * Assumes all conditions are met and then checks each of them,
     * any condition not met will invalidate the rule, meaning the answer
     * is valid.
     *
     * **** DONT TOUCH THIS, EVER. ****
     *
     * @param string $elname   The name of the element being validated
     * @param array  $elements Array of values submitted on current page.
     * @param array  $rules    Array of rules that have been registered.
     *
     * @return array of errors (fieldname => error message)
     */
    function XINRunElementRules(
        string $elname,
        array $elements,
        array $rules
    ): array {
        $errors = array();
        //Conditions for the rule to be true, thus the element to be required.
        $rule_outcomes = array();

        foreach ($rules['rules'] AS $rule) {
            //Loop through the assigned rules (which is the array of formatted
            //statements passed in XINRegisterRule)
            //If this is an OR rule using two different controllers explode it
            //at the pipe.  ex: q_1{@}=={@}yes|q_2{@}=={@}yes
            $isInterfieldOr = false;
            if (substr_count($rule, '{@}') > 2 && strstr($rule, '|')) {
                $rules_array    = explode("|", $rule);
                $isInterfieldOr = true;
            } else {  //Otherwise its a regular rule.  ex: q_1{@}=={@}yes
                $rules_array[] = $rule;
            }
            //Loop through the rules (will only be one rule if this is not an OR)
            $or_conditions = false;
            for ($i = 0; $i < count($rules_array); $i++) {
                $rule = explode("{@}", $rules_array[$i]);
                //Some rules compare against multiple values, handle this here.
                if (stristr($rule[2], "|")) {  //ex: q_1{@}=={@}yes|no
                    $values = explode("|", $rule[2]);
                } else {  //ex: q_1{@}=={@}yes
                    $values = array($rule[2]);
                }

                //Test the condition
                if ($this->XINDebug) {
                    //debugging code
                    echo "$rule[0] ";
                }

                //Handle select multiples who's controllre values are arrays.

                //explicitly cast the controller value as an array
                if (!is_array($elements[$rule[0]])) {
                    $elements[$rule[0]] = array($elements[$rule[0]]);
                }
                //Foreach controller value run the rule.
                foreach ($elements[$rule[0]] as $controller_value) {
                    $ElementResult = $this->XINRunRuleFunction(
                        $controller_value,
                        $values,
                        $rule[1]
                    );

                    if ($ElementResult) {
                        $or_conditions = true; //If any of the OR rules is true
                    } else if (!$isInterfieldOr) {
                        $or_conditions = false;
                    }
                }
            }
            //If NONE of the or_conditions were true the field is NOT required.
            if ($or_conditions == false) {
                $rule_outcomes[] = false;
            } else {
                $rule_outcomes[] = true;
            }
        }
        //If all of the conditions were true then print the error message
        if (!in_array(false, $rule_outcomes)) {
            $el          = $rules['group'] != "" ? $rules['group'] : $elname;
            $errors[$el] = $rules['message'];
        }
        return $errors;
    }

    /**
     * Run a XIN rule on an individual element
     *
     * @param ?string $controller The element which affects the validity of this
     *                           element
     * @param array   $values     Array of values which will invalidate the rule.
     * @param string  $operator   The operator which is used to compare the rule.
     *
     * @return boolean true if element should be required, false otherwise.
     */
    function XINRunRuleFunction(
        ?string $controller,
        array $values,
        string $operator
    ): bool {
        $is_required = true;
        //Loop through the conditions to test against (for most rules it
        //will only be one value)
        //If all of the conditions are true (ie: all conditions are met
        //to pop a required rule)
        $valFlag = array();
        foreach ($values AS $value) {
            switch ($operator) {
            case '==':
                if ($controller != $value) {
                    $valFlag[] = false;
                }
                break;
            case '!=':
                if ($controller == $value) {
                    $valFlag[] = false;
                }
                break;
            default:
                throw new \LorisException(
                    "Unsupported operator ($operator) for XIN Rule."
                    . " If this used to work, please file a bug report."
                );
            }
            if ($this->XINDebug) {
                //debugging code
                echo "'$controller' $operator '$value'<br>";
            }
        }
        //For conditions
        if (count($valFlag) == count($values)) {
            $is_required = false;
        }
        return $is_required;
    }

    /**
     * Get a the value of $field from the instrument table.
     * Used specifically by electronic instruments to check if file
     * is already uploaded.
     *
     * @param string $field The field to get from this instrument
     *
     * @return string|false The value of the field, or false if it's empty.
     */
    function getFieldValue(string $field)
    {
        $allValues = self::loadInstanceData($this);

        if (!empty($allValues[$field])) {
            return $allValues[$field];
        }
        return false;
    }


    /**
     * Gets the sessionID for the timepoint to which this instrument pertains
     *
     * @return int The sessionID if found, or -1 if not found
     */
    function getSessionID(): int
    {
        $query      = "SELECT SessionID FROM flag WHERE CommentID = :CID";
        $fieldValue = \Database::singleton()->pselectOne(
            $query,
            array(
             'CID' => $this->getCommentID(),
            )
        );

        if (!empty($fieldValue)) {
            return $fieldValue;
        }
        return -1;
    }

    /**
     * Gets the VisitLabel for the timepoint to which this instrument pertains
     *
     * @return String for the VisitLabel
     */
    function getVisitLabel(): string
    {
        $sessionID = $this->getSessionID();

        if ($sessionID !== -1) {
            $timepoint  = \TimePoint::singleton($sessionID);
            $visitLabel = $timepoint->getVisitLabel();
            return $visitLabel;
        }
        return '';
    }

    /**
     * Gets the subprojectID for the timepoint to which this instrument pertains
     *
     * @return int|null The subprojectID
     */
    function getSubprojectID(): ?int
    {
        $sessionID = $this->getSessionID();
        if ($sessionID !== -1) {
            $timepoint    = \Timepoint::singleton($sessionID);
            $subprojectID = $timepoint->getSubprojectID();
            return $subprojectID;
        }
        return null;
    }


    /**
     * Determines what the data entry status flag should be set to
     *
     * @return string  Either 'Complete' or 'Incomplete'
     */
    function _determineDataEntryCompletionStatus(): string
    {
        // don't bother checking anything if the required elements array is empty
        if (empty($this->_requiredElements)) {
            return 'Complete';
        }

        $allData = $this->loadInstanceData($this);
        foreach ($this->_requiredElements as $field) {
            // this shouldn't be just empty() b/c 0 is a valid
            // value for some required fields
            if (is_null($allData[$field]) || $allData[$field] === "") {
                return 'Incomplete';
            }
        }

        return 'Complete';
    }


    /**
     * Gets the data entry completion status for this instrument
     *
     * @return string Either 'Complete' or 'Incomplete'
     */
    function getDataEntryCompletionStatus(): string
    {
        $data = NDB_BVL_Instrument::loadInstanceData($this);
        return $data["Data_entry_completion_status"];
    }


    /**
     * Sets the data entry completion status
     *
     * @param string $status The status - either 'Complete'
     *                       or 'Incomplete'
     *
     * @return void
     */
    function _setDataEntryCompletionStatus(string $status): void
    {
        if (!in_array($status, array('Complete', 'Incomplete'))) {
            throw new Exception(
                "Invalid status passed to _setDataEntryCompletionStatus - "
                . "'$status' should have been either "
                . "'Complete' or 'Incomplete'<br>\n"
            );
        }

        $this->_save(array("Data_entry_completion_status" => $status));
    }

    /**
     * Wrapper to auto-create a simple Yes, No, Null, Not Answered type
     * of question
     *
     * @param string $field        The database field in which the response
     *                             will be stored
     * @param string $label        The question text to display
     * @param array  $rules        {@} delimited rules
     * @param string $rule_message rule message to display
     *
     * @return void
     */
    function addYesNoElement(
        string $field,
        string $label,
        array $rules=array(),
        string $rule_message='This field is required.'
    ): void {
        $this->addSelect(
            $field,
            $label,
            array(
             null           => '',
             'yes'          => 'Yes',
             'no'           => 'No',
             'not_answered' => 'Not Answered',
            )
        );

        if (!empty($rules)) {
            $this->XINRegisterRule($field, $rules, $rule_message);
        }
    }

    /**
     * Wrapper to create a text field with an accompanying status field.
     *
     * @param string $field        The database field in which the response
     *                             will be stored
     * @param string $label        The question text to display
     * @param array  $rules        rules with values and comparisson operators
     *                             {@} seperated.
     *                             Example: array(
     *                             'q_40{@}=={@}1_yes',
     *                             'q_40_b{@}=={@}1_yes'
     *                             )
     * @param string $rule_message rule message to display
     * @param array  $refusals     options in the refusal select (ie. Refusal,
     *                             Unknown, Not Answered).
     *
     * @return void
     */
    function addTextElement(
        string $field,
        string $label,
        array $rules=array(),
        string $rule_message='This field is required.',
        array $refusals = array(
                           ''             => '',
                           'not_answered' => 'Not Answered',
                          )
    ): void {
        $group[] = $this->createText($field, $label);
        $this->WrapperTextElements[$field] = $group[0];
        $group[] = $this->createSelect(
            $field."_status",
            "",
            $refusals,
            array('class' => 'form-control input-sm not-answered')
        );

        $this->addGroup($group, $field.'_group', $label, null, false);
        unset($group);
        $rules_array = array_merge(array($field.'_status{@}=={@}'), $rules);
        $this->XINRegisterRule($field, $rules_array, $rule_message, $field.'_group');
    }

    /**
     * Wrapper to create a text area field for questions that require
     * Refused and Don't know options
     *
     * @param string $field        The database name for this field
     * @param string $label        The question text
     * @param array  $rules        XINRules for this question
     * @param string $rule_message The error message if rules are violated
     *
     * @return void
     * @note   This was only ever used by the EARLI instrument and should be moved
     *       out of the NDB_BVL_Instrument into an EARLI base class.
     */
    function addTextAreaElementRD(string $field,
        string $label,
        array $rules=array(),
        string $rule_message='You must specify or select from the drop-down'
    ): void {
        $group[] = $this->form->createElement(
            "textarea",
            $field,
            null,
            array(
             'cols' => 25,
             'rows' => 4,
            )
        );
        $group[] = $this->createSelect(
            $field."_status",
            "",
            array(
             null             => '',
             "88_refused"     => "88 Refused",
             "99_do_not_know" => "99 Do not know",
             'not_answered'   => 'Not Answered',
            )
        );

        $this->addGroup($group, $field.'_group', $label, null, false);
        unset($group);
        $rules_array = array_merge(array($field.'_status{@}=={@}'), $rules);
        $this->XINRegisterRule($field, $rules_array, $rule_message, $field.'_group');
    }

    /**
     * Wrapper to create a text area field, with an accompanying status field.
     *
     * @param string $field        The database field in which the response
     *                             will be stored
     * @param string $label        The question text to display
     * @param array  $rules        {@} delimited rules
     * @param string $rule_message rule message to display upon rule violation
     *
     * @return void
     */
    function addTextAreaElement(
        string $field,
        string $label,
        array $rules=array(),
        string $rule_message='This field is required.'
    ): void {
        $group[] = $this->form->createElement(
            "textarea",
            $field,
            $label,
            array(
             'cols'  => 25,
             'rows'  => 4,
             'class' => 'form-control',
            )
        );
        $this->WrapperTextElements[$field] = $group[0];
        $group[] = $this->createSelect(
            $field."_status",
            "",
            array(
             null           => '',
             'not_answered' => 'Not Answered',
            ),
            array('class' => 'form-control input-sm not-answered')
        );
        $this->addGroup($group, $field.'_group', $label, null, false);
        unset($group);
        $rules_array = array_merge(array($field.'_status{@}=={@}'), $rules);
        $this->XINRegisterRule(
            $field,
            $rules_array,
            $rule_message,
            $field.'_group'
        );
    }

    /**
     * Wrapper to create an Hour/Minute field, with an accompanying status field.
     *
     * @param string      $field        Name given to the HTML QuickForm Element
     *                                  being created
     * @param string      $label        The question text to display
     * @param array       $rules        Additional rules to apply to the element
     *                                  being added,{@} delimited
     * @param string|null $rule_message Message to display upon rule violation.
     *
     * @return void
     * @note   only used by EARLI? What is "dnk"? This should be cleaned up to use
     */
    function addHourMinElement(
        string $field,
        string $label,
        array $rules = array(),
        ?string $rule_message = null
    ): void {
        if ($rule_message === null) {
            $rule_message = "You are required to select a status "
                . "if you want to leave this time blank.";
        }

        $group[] = $this->form->createElement(
            "time",
            $field,
            null,
            null,
            null
        );

        $group[] = $this->createSelect(
            $field . "_status",
            "",
            array(
             null           => '',
             "dnk"          => "DNK",
             "refusal"      => "Refusal",
             'not_answered' => 'Not Answered',
            )
        );
        $this->addGroup($group, $field . "_group", $label, null, false);
        $this->XINRegisterRule(
            $field,
            array_merge($rules, array($field . '_status{@}=={@}')),
            $rule_message,
            $field . '_group'
        );
        unset($group);
    }

    /**
     * Adds a date group with a status box and appropriate rule
     * Note: $this->dateOptions must be defined by the subclass calling this
     * wrapper function
     *
     * @param string $name    Name prepended to the HTMLQuickform element
     * @param string $label   Element label
     * @param array  $options optional override of class's dateOptions
     *
     * @return void
     */
    function addDateElement(
        string $name,
        string $label,
        array $options = array()
    ): void {

        if (empty($options)) {
            $options = $this->dateOptions;
        }

        $group[] = $this->createDate(
            $name . "_date",
            $label,
            $options,
            array(
             'class' => 'form-control input-sm '.$name."_date",
             'style' => 'max-width:33%; display:inline-block;',
            )
        );
        $this->WrapperDateWithStatusElements[$name . "_date"] = $group[0];
        if (!in_array($name . "_date", $this->dateTimeFields)) {
            $this->dateTimeFields[] = $name . "_date";
        }

        $group[] = $this->createSelect(
            $name . "_date_status",
            null,
            array(
             null           => "",
             'not_answered' => "Not Answered",
            ),
            array('class' => 'form-control input-sm not-answered')
        );

        $this->addGroup(
            $group,
            $name . "_date_group",
            $label,
            $this->_GUIDelimiter,
            false
        );

        unset($group);
        $this->XINRegisterRule(
            $name . "_date",
            array($name . "_date_status{@}=={@}"),
            "A Date, or Not Answered is required.",
            $name . "_date_group"
        );
    }

    /**
     * Wrapper to create a month year date field
     *
     * This is only used in instruments and not in NDB_Page because
     * special logic is needed in the _saveValues to deal with the
     * monthYear fields.
     *
     * @param string $field   Name of the field
     * @param string $label   Element label
     * @param array  $options optional override of class's dateOptions
     *
     * @return void
     */
    function addMonthYear(string $field, string $label, array $options=array()): void
    {
        if (is_array($options)) {
            $options['format'] = 'YM';
        }
        $this->form->addElement('date', $field, $label, $options);
        $this->monthYearFields[] = $field;
    }


    /**
     * Wrapper with a user-created date group, a status box and appropriate rule
     *
     * @param string $name      The database name to add to the form
     * @param string $label     The question text
     * @param array  $dateArray QuickForm date options to use
     *
     * @return void
     * @note   This was only ever used by the EARLI instrument and should be
     *       moved out of the NDB_BVL_Instrument into an EARLI base class.
     */
    function addCustomDateElement(
        string $name,
        string $label,
        array $dateArray
    ): void {
        $group[] = $this->createDate($name . "_date", null, $dateArray);
        //add to array of dates and times.
        $this->dateTimeFields[] = $name . "_date";
        $group[] = $this->createSelect(
            $name . "_date_status",
            null,
            array(
             null             => "",
             '88_refused'     => "88 Refused",
             '99_do_not_know' => "99 Do not know",
             'not_answered'   => "Not Answered",
            )
        );
        $this->addGroup(
            $group,
            $name . "_date_group",
            $label,
            $this->_GUIDelimiter,
            false
        );
        unset($group);
        $this->XINRegisterRule(
            $name . "_date",
            array($name . "_date_status{@}=={@}"),
            "You must specify or select from the drop-down",
            $name . "_date_group"
        );
        $this->XINRegisterRule(
            $name . "_date_status",
            array($name . "_date{@}=={@}"),
            "You must specify or select from the drop-down",
            $name . "_date_group"
        );

    }



    /**
     * Wrapper to create a field that only accepts a number, with an
     * accompanying status field.
     *
     * @param string $field The database field in which the response
     *                      will be stored
     * @param string $label The question text to display
     *
     * @return void
     */
    function addNumericElement(
        string $field,
        string $label
    ): void {
        $group[] = $this->createText($field, $label);
        $this->WrapperNumericElements[$field] = $group[0];
        $group[] = $this->createSelect(
            $field . "_status",
            null,
            array(
             null           => "",
             'not_answered' => "Not Answered",
            ),
            array('class' => 'form-control input-sm not-answered')
        );
        $this->addGroup($group, $field . "_group", $label, null, false);
        unset($group);
        $this->addGroupRule(
            $field . "_group",
            array(array(array("Value must be numeric.", 'numeric')))
        );
        $this->XINRegisterRule(
            $field,
            array($field . '_status{@}=={@}'),
            'This field is required',
            $field . '_group'
        );
    }

    /**
     * Wrapper to create a field that only accepts a number, for questions that
     * require refused and don't know options
     *
     * @param string $field The database name to add
     * @param string $label The user friendly label to display
     *
     * @return void
     */
    function addNumericElementRD(string $field, string $label): void
    {
        $group[] = $this->createText($field, $label);
        $group[] = $this->createSelect(
            $field . "_status",
            null,
            array(
             null             => "",
             "88_refused"     => "88 Refused",
             "99_do_not_know" => "99 Do not know",
             'not_answered'   => "Not Answered",
            ),
            array('class' => 'form-control input-sm not-answered')
        );
        $this->addGroup($group, $field . "_group", $label, null, false);
        unset($group);
        $this->addGroupRule(
            $field . "_group",
            array(array(array("Numbers only, please", 'numeric')))
        );
        $this->XINRegisterRule(
            $field,
            array($field . '_status{@}=={@}'),
            'This field is required',
            $field . '_group'
        );
    }


    /**
     * Nulls all scores for the record identified by CommentID. This should
     * be done at the start of any scoring run to ensure that old data is
     * nulled before the current score run, in case a change in the data
     * affected which scores are calculated so that the old (incorrect) data
     * doesn't remain.
     *
     * @param array $scoreCols list of scoring fields to null
     *
     * @return void
     */
    function _nullScores(array $scoreCols): void
    {
        $data = $this->loadInstanceData($this);

        // set the scoring cols to NULL
        foreach ($scoreCols as $key => $val) {
            // Some Instruments use an associative array for
            // $scoreCols of the form column => description, others
            // use a non-associative array. So if the key is numeric,
            // and we need to make sure we use the column name
            if (is_numeric($key)) {
                $data[$val] = null; //null array
            } else {
                $data[$key] = null;
            }

        }

        $this->_save($data);
        return;
    }

    /**
     * Computes the difference between two instances of this instrument.
     *
     * @param NDB_BVL_Instrument $otherInstrument The instrument to compare
     *                                            the currently instantiated
     *                                            instrument again.
     *
     * @return array The keys which are not shared between the passed instrument
     *         and the current one.
     */
    function diff(NDB_BVL_Instrument $otherInstrument): array
    {
        // Load this instance data
        $thisData = NDB_BVL_Instrument::loadInstanceData($this);

        // Load other instance data
        $otherData = NDB_BVL_Instrument::loadInstanceData($otherInstrument);

        // Create the return object data structure
        $diff = array();

        // Loop over this instance data
        foreach ($thisData AS $key=>$value) {
            if (!in_array($key, $this->_doubleDataEntryDiffIgnoreColumns)) {
                if ($otherData[$key] != $value) {
                    $diff[] = array(
                               'TableName'      => $this->table,
                               'ExtraKeyColumn' => null,
                               'ExtraKey1'      => ' ',
                               'ExtraKey2'      => ' ',
                               'FieldName'      => $key,
                               'CommentId1'     => $this->getCommentID(),
                               'Value1'         => $value,
                               'CommentId2'     => $otherInstrument->getCommentID(),
                               'Value2'         => $otherData[$key],
                              );
                }
            }
        }

        // Return the diffs
        return $diff;
    }

    /**
     * Gets the data from an instrument out of the database and returns it
     * as an array.
     *
     * @param NDB_BVL_Instrument $instrumentInstance The object whose data is
     *                                               to be retrieved.
     *
     * @return array containing the data for each field in this instrument
     */
    static function loadInstanceData(NDB_BVL_Instrument $instrumentInstance): array
    {
        $db = \Database::singleton();

        if ($instrumentInstance->jsonData) {
            $jsondata = $db->pselectOne(
                "SELECT Data FROM flag WHERE CommentID=:CID",
                array('CID' => $instrumentInstance->getCommentID())
            );
            return json_decode($jsondata, true) ?? array();
        } else {
            $defaults = $db->pselectRow(
                "SELECT * FROM $instrumentInstance->table WHERE CommentID=:CID",
                array('CID' => $instrumentInstance->getCommentID())
            );
            return $defaults ?? array();
        }
    }

    /**
     * Calculates the candidate's age at the time of this instrument.
     * If Date_taken is passed, this function  will calculate the age as of
     * the value of that argument. This is used, for instance, in
     * _saveValues when we want to calculate the age based on the new
     * value and not based on the age saved in the database. Otherwise
     * the date will be calculated based on the value of the Date_taken
     * field in the database.
     *
     * @param string $date (optional) The date that the age is to
     *                     be calculated based on.
     *
     * @return array The age of the candidate in an array containing years, months
     *         and days.
     */
    function getCandidateAge(string $date): array
    {
        $dates = array(
                  'Date_taken' => $this->getFieldValue('Date_taken'),
                  'DoB'        => $this->getDoB(),
                 );

        $age = array();
        if (empty($date)) {
            $age = Utility::calculateAge($dates['DoB'], $dates['Date_taken']);
        } else {
            $age = Utility::calculateAge($dates['DoB'], $date);
        }
        //Format: array with keys 'year', 'mon', 'day'
        return $age;
    }

    /**
     * Get the candidates DOB.
     *
     * @return string The candidate's DOB.
     */
    function getDoB()
    {
        $db        = \Database::singleton();
        $CommentID = $this->getCommentID();

        $dob = $db->pselectOne(
            "SELECT c.DoB FROM flag f
            JOIN session s ON (f.SessionID=s.ID)
            JOIN candidate c USING (CandID)
            WHERE f.CommentID=:CID",
            array('CID' => $CommentID)
        );
        return $dob;
    }

    /**
     * Get the candidates PSCID.
     *
     * @return string|null The candidate's PSCID.
     */
    function getPSCID(): ?string
    {
        $db        = \Database::singleton();
        $CommentID = $this->getCommentID();

        $pscid = $db->pselectOne(
            "SELECT c.PSCID FROM flag f
            JOIN session s ON (f.SessionID=s.ID)
            JOIN candidate c USING (CandID)
            WHERE f.CommentID=:CID",
            array('CID' => $CommentID)
        );
        return $pscid;
    }

    /**
     * Clears all the data saved into this instrument instance
     *
     * @return void
     */
    function clearInstrument(): void
    {
        $config   = NDB_Config::singleton();
        $db       = Database::singleton();
        $dbconfig = $config->getSetting('database');
        $columns  = $db->pselect(
            "SELECT COLUMN_NAME FROM information_schema.columns
            WHERE TABLE_NAME=:table AND TABLE_SCHEMA=:db",
            array(
             'table' => $this->table,
             'db'    => $dbconfig['database'],
            )
        );

        $values = array();
        foreach ($columns as $row) {
            switch ($row['COLUMN_NAME']) {
            case 'CommentID':
            case 'UserID':
                continue 2;
            case 'Data_entry_completion_status':
                $values[$row['COLUMN_NAME']] = 'Incomplete';
                break;
            default:
                $values[$row['COLUMN_NAME']] = null;
            }
        }
        $db->update($this->table, $values, array('CommentID' => $this->commentID));
        $prepQ = $db->prepare(
            "DELETE FROM conflicts_unresolved
             WHERE (CommentId1=:CID OR CommentId2=:CID)"
        );
        $db->execute($prepQ, array('CID' => $this->commentID));
    }

    /**
     * Parses a file that isn't written in PHP and loads it into a format
     * that LORIS understands.
     *
     * This is intended to be overridden by a subclass of NDB_BVL_Instrument
     * to add support for other file formats.
     *
     * @param string  $filename The filename to be loaded, or a base64 encoded
     *                          string.
     * @param boolean $base64   If true, read the filename as a base64 encoded
     *                          string of the file content, used for preview.
     *
     * @return void
     */
    function loadInstrumentFile(string $filename, bool $base64 = false): void
    {
    }

    /**
     * Load the rules for an instrument from the file system.
     *
     * This is intended to be overridden by a subclass of NDB_BVL_Instrument
     * to add support for other file formats.
     *
     * @param string $filename Either the path to a file, or a base64 encoded
     *                         string which can be interpreted as a file by
     *                         PHP and fopen()
     * @param bool   $base64   If true, the "filename" is really a base64 encoded
     *                         data URL, so we shouldn't check that the file exists
     *                         on the filesystem. (Used by preview)
     *
     * @return void
     */
    function loadInstrumentRules(string $filename, bool $base64 = false): void
    {
    }

    /**
     * Renders the HTML for the control panel for this instrument.
     *
     * @return string The HTML for the control panel
     */
    function getControlPanel(): string
    {
        if (!empty($_REQUEST['commentID'])) {
            // make the control panel object for the current instrument
            $controlPanel = new NDB_BVL_InstrumentStatus_ControlPanel;
            $controlPanel->select($_REQUEST['commentID']);

            $config = NDB_Config::singleton();
            $paths  = $config->getSetting('paths');

            // check if the file/class exists
            $BasePath = $paths['base'] . 'project/instruments/';
            $TestName = $this->testName;
            if (file_exists(
                $BasePath
                    . "NDB_BVL_Instrument_$TestName.class.inc"
            )
                || file_exists($BasePath . "$TestName.linst")
            ) {
                // save possible changes from the control panel...
                $controlPanel->save();
            }

            // display the control panel
            $html = $controlPanel->display();
            return $html;
        }
    }

    /**
     * Function that displays the html the fetch feedback panel.
     *
     * @param int $candID    The candidate ID for the panel.
     * @param int $sessionID The session ID for the panel.
     *
     * @return string
     */
    function getFeedbackPanel(int $candID, int $sessionID): string
    {

        $commentID = $this->getCommentID();

        if (!empty($commentID)) {
            $feedbackPanel = new BVL_Feedback_Panel(
                $candID,
                $sessionID,
                $commentID
            );

            return $feedbackPanel->display();
        }
    }

    /**
     * Return the HTML for the review section of the survey module
     * By default, this will show every question from the parameter_type
     * table for this instrument, but it can be overridden/customized by
     * a instrument if that isn't the desired behaviour.
     *
     * @return string The HTML to be inserted into the review section of
     *                the final page of the survey module for this instrument.
     */
    function getReview(): string
    {
        $DB = Database::singleton();

        $smarty   = new Smarty_neurodb();
        $tpl_data = array();

        $tpl_data['questions'] = $DB->pselect(
            "SELECT Description as question,
            SourceField FROM parameter_type
            WHERE SourceFrom=:TN AND
            SourceField NOT IN ('Validity', 'Administration')",
            array('TN' => $this->testName)
        );

        $Responses = $DB->pselectRow(
            "SELECT * FROM " . $this->table . " WHERE CommentID=:CID",
            array('CID' => $this->getCommentID())
        );

        foreach ($tpl_data['questions'] as &$row) {
            if (isset($Responses[$row['SourceField']])) {
                $row['response'] = $Responses[$row['SourceField']];
            }
        }

        $smarty->assign($tpl_data);
        $html = $smarty->fetch("directentry_review.tpl");
        return $html;
    }


    /**
     * Parse the HTML generated by smarty for the current element to
     * extract information that is not directly extractable by the
     * smarty array renderer, but is still needed in order to render
     * the instrument as JSON.
     *
     * @param array $element The current element that came from smarty
     *
     * @return array of the element in format understood by instrument_json.tpl
     */
    function _toJSONParseSmarty(array &$element): array
    {
        /* Hacks to get data that QuickForm_Renderer_Array doesn't provide
         * an easy way to get */
        if ($element['type'] === 'select') {
            // Parse the HTML to get the options from the select
            $html = new DOMDocument();
            $html->loadHTML($element['html']);

            $element['options'] = array();

            $selectEl = $html->getElementsByTagName("select")->item(0);

            if ($selectEl->getAttribute("multiple") == 'multiple') {
                $element['Multiselect'] = true;
            }

            foreach ($html->getElementsByTagName("option") as $option) {
                if ($option->getAttribute("value") === 'not_answered') {
                    $element['RequireResponse'] = true;
                } else {
                    $element['options'][$option->getAttribute("value")]
                        = $option->textContent;
                }
            }
        } else if ($element['type'] === "date") {
            if (get_class($this->form) === 'LorisForm') {
                $element['options'] = array(
                                       'mindate'         => "1990-01-01",
                                       'maxdate'         => "2000-12-31",
                                       'RequireResponse' => false,
                                      );
                //$element['RequireResponse'] = false;
            } else {
                $html = new DOMDocument();
                $html->loadHTML($element['html']);
                // Parse the HTML to get the min and max date
                $selects = $html->getElementsByTagName("select");
                if ($selects->length > 0) {
                    // Old school QuickForm style. This should be removed
                    // after QuickForm is retired.
                    $year = $selects->item(0);

                    // If Item 0 is blank, item 1 is the minimum,
                    $minYear = $year->childNodes->item(0)->textContent;

                    // PHP's trim function doesn't support UTF-8's 0xC2A0 (&nbsp;),
                    // which seems to be how loadHTML parses spaces. Trim whitespace
                    // and then specifically trim that character before checking if
                    // the year is empty, and if it's empty use the next option in
                    // the dropdown (which should be non-empty)
                    $minYear = trim($minYear);
                    $minYear = trim($minYear, chr(0xC2).chr(0xA0));
                    if (empty($minYear)) {
                        $minYear = $year->childNodes->item(1)->textContent;
                    }
                    // the last item is the maximum year
                    $maxYear = $year->lastChild->textContent;

                    $element['options'] = array(
                                           'mindate' => $minYear . "-01-01",
                                           'maxdate' => $maxYear . "-12-31",
                                          );

                }
            }
            if (isset($this->WrapperDateWithStatusElements[$element['name']])) {
                $element['NoResponse'] = false;
            } else {
                $element['NoResponse'] = true;
            }

        }
        return $element;
    }

    /**
     * Parses and element that came from HTML_QuickForm_Renderer_Array
     * and converts it to a format useable by instrument_json.tpl
     *
     * @param array $element   The element from the QuickForm array renderer
     * @param array $formArray The currently existing form that was converted
     *                         to instrument_json.tpl format.
     *
     * @return void (but side-effect modified $formArray to populate the element
     *         with the appropriate format needed for JSON serialization.)
     */
    function _toJSONParsePageElement(array &$element, array &$formArray): void
    {
        $name = isset($element['name']) ? $element['name'] : '';
        if ($element['type'] === 'group') {
            $elementName = str_replace("_group", '', $name);
            if (isset($this->WrapperTextElements[$elementName])) {
                // Convert text elements created by wrapper into
                // the native type.
                $mapFunc = function (&$el) use ($name, $elementName) : void {
                    if ($el['name'] === $name) {
                        $el['name'] = $elementName;
                        $elObj      = $this->WrapperTextElements[$elementName];
                        if ((is_array($elObj)
                            && $elObj['type'] === 'textarea')
                            || (!is_array($elObj) && $elObj->_type == 'textarea')
                        ) {
                            $el['type'] = 'textarea';
                        } else {
                            $el['type'] = 'text';
                        }
                    }
                };
                array_map($mapFunc, $formArray['elements']);
                $element['label'] = $element['elements'][0]['label'];
            }

            if (isset($this->WrapperNumericElements[$elementName])) {
                $mapFunc = function (&$el) use ($name, $elementName) : void {
                    if ($el['name'] === $name) {
                        $el['name'] = $elementName;
                        $el['type'] = 'numeric';
                    }
                };
                array_map($mapFunc, $formArray['elements']);
                $element['label'] = $element['elements'][0]['label'];
            }

            if (isset($this->WrapperDateWithStatusElements[$elementName])) {
                // Convert date elements created by wrapper into
                // the native type.
                $mapFunc = function (&$el) use ($name, $elementName) : void {

                    if ($el['name'] === $name) {
                        $el['name'] = $elementName;
                        $el['type'] = 'date';
                        if (isset($el['elements'][0]['label'])) {
                            $el['label'] = $el['elements'][0]['label'];
                        }
                        //unset($el['elements']);
                        //unset($el['delimiter']);
                        //$label = $el['label'];
                        //$el = $this->_toJSONParseSmarty($el['elements'][0]);
                        //$el['label'] = $label;
                        //$el = $this->_toJSONParseSmarty($el);
                    }
                };
                array_map($mapFunc, $formArray['elements']);
                $element['label'] = $element['elements'][0]['label'];
            }
            unset($formArray['elements'][$name]);
        }
        if (strpos($name, "_status") === false) {
            $this->_toJSONParseSmarty($element);
        } else {
            unset($formArray['elements'][$name]);
        }
    }

    /**
     * Uses smarty to parse the current instrument page into a format
     * that can be converted to JSON
     *
     * @return array of elements on the current page
     */
    function _toJSONParsePage(): array
    {

        if (get_class($this->form) === 'LorisForm') {
            $formArray = $this->form->toElementArray();
        } else {
            $smarty   = new Smarty_neurodb;
            $renderer = new HTML_QuickForm_Renderer_Array($smarty);

            $this->form->accept($renderer);

            $formArray = $renderer->toArray();
        }

        if (isset($formArray['elements'])) {
            foreach ($formArray['elements'] as &$element) {
                $this->_toJSONParsePageElement($element, $formArray);
            }
        }

        if (isset($formArray['sections'])) {
            foreach ($formArray['sections'] as &$section) {
                if (isset($section['elements'])) {
                    foreach ($section['elements'] as &$element) {
                        $this->_toJSONParsePageElement($element, $section);
                    }
                } else {
                    $this->_toJSONParsePageElement($element, $section);
                }
            }
        }
        return $formArray;

    }
    /**
     * Returns a JSON representation of the currently instantiated
     * instrument.
     *
     * The format of the JSON representation is specified in the
     * docs/API/InstrumentFormat documentation.
     *
     * @return string containing valid JSON
     */
    function toJSON(): string
    {
        $smarty = new Smarty_neurodb;
        //$renderer = new HTML_QuickForm_Renderer_Array($smarty);

        $subtests = $this->getSubtestList();
        foreach ($subtests as $subtest) {
            if (get_class($this->form) === 'LorisForm') {
                $this->form->addPageBreak(
                    $subtest['Name'],
                    $subtest['Description'],
                    array()
                );
            }
            $this->page = $subtest['Name'];
            $this->_setupForm();
        }
        $formArray = $this->_toJSONParsePage();

        $smarty->assign('form', $formArray);
        $smarty->assign('testname', $this->testName);
        $smarty->assign('fullname', $this->getFullName());
        $html = $smarty->fetch("instrument_json.tpl");

        return json_encode(json_decode($html));
    }

    /**
     * Determines whether data entry should be allowed for this instrument
     * or not.
     *
     * @return boolean true if data entry is permitted
     */
    function determineDataEntryAllowed(): bool
    {
        $DB    = Database::singleton();
        $entry = $DB->pselectOne(
            "SELECT Data_entry FROM flag WHERE CommentID=:CID",
            array('CID' => $this->getCommentId())
        );

        if ($entry === 'Complete') {
            return false;
        }
        return true;
    }

    /**
     * Validate whether the values submitted are valid
     *
     * @param array $values an array of values submitted
     *
     * @return boolean true if values are valid
     */
    function validate(array $values): bool
    {
        return $this->determineDataEntryAllowed();
    }

    /**
     * Generate a breadcrumb trail for this page.
     *
     * @return \LORIS\BreadcrumbTrail
     */
    public function getBreadcrumbs(): \LORIS\BreadcrumbTrail
    {
        $visitlabel = $this->getVisitLabel();
        $sessionid  = $this->getSessionID();
        $timepoint  = \TimePoint::singleton($sessionid);
        $candid     = $timepoint->getCandID();
        $pscid      = $this->getPSCID();
        $instrument = $this->testName;

        return new \LORIS\BreadcrumbTrail(
            new \LORIS\Breadcrumb(
                'Access Profile',
                '/candidate_list'
            ),
            new \LORIS\Breadcrumb(
                "Candidate Profile $candid / $pscid",
                "/$candid"
            ),
            new \LORIS\Breadcrumb(
                "TimePoint $visitlabel Details",
                "/instrument_list/?candID=$candid&sessionID=$sessionid"
            ),
            new \LORIS\Breadcrumb(
                $this->getFullName(),
                "/instruments/$instrument/?commentID=$this->commentID"
            )
        );
    }

    /**
     * Returns true if this instrument saves its data in JSON format to
     * the flag column, rather than directly in MySQL tables.
     *
     * @return bool true if data is saved in the flag table
     */
    public function usesJSONData() : bool
    {
        return $this->jsonData;
    }
}

