<?php


 /**
  * Candidate Value Object.
  * This class is value object representing database table Candidate
  * This class is intented to be used together with associated Dao object.
  */

 /**
  * This sourcecode has been generated by FREE DaoGen generator version 2.4.1.
  * The usage of generated code is restricted to OpenSource software projects
  * only. DaoGen is available in http://titaniclinux.net/daogen/
  * It has been programmed by Tuomo Lukka, Tuomo.Lukka@iki.fi
  *
  * DaoGen license: The following DaoGen generated source code is licensed
  * under the terms of GNU GPL license. The full text for license is available
  * in GNU project's pages: http://www.gnu.org/copyleft/gpl.html
  *
  * If you wish to use the DaoGen generator to produce code for closed-source
  * commercial applications, you must pay the lisence fee. The price is
  * 5 USD or 5 Eur for each database table, you are generating code for.
  * (That includes unlimited amount of iterations with all supported languages
  * for each database table you are paying for.) Send mail to
  * "Tuomo.Lukka@iki.fi" for more information. Thank you!
  */




class Candidate_VO {

    /** 
     * Persistent Instance variables. This data is directly 
     * mapped to the columns of database table.
     */
    var $ID;
    var $CandID;
    var $PSCID;
    var $ExternalID;
    var $DoB;
    var $EDC;
    var $Gender;
    var $CenterID;
    var $ProjectID;
    var $Ethnicity;
    var $Active;
    var $Date_active;
    var $RegisteredBy;
    var $UserID;
    var $Date_registered;
    var $flagged_caveatemptor;
    var $flagged_reason;
    var $flagged_other;
    var $flagged_other_status;
    var $Testdate;
    var $Entity_type;
    var $ProbandGender;
    var $ProbandDoB;



    /** 
     * Constructors. DaoGen generated constructors takes no arguments
     * and provides the most simple way to create object instance. 
     */
    function Candidate_VO () {

    }

    /** 
     * Get- and Set-methods for persistent variables. The default
     * behaviour does not make any checks against malformed data,
     * so these might require some manual additions.
     */

    function getID() {
          return $this->ID;
    }
    function setID($IDIn) {
          $this->ID = $IDIn;
    }

    function getCandID() {
          return $this->CandID;
    }
    function setCandID($CandIDIn) {
          $this->CandID = $CandIDIn;
    }

    function getPSCID() {
          return $this->PSCID;
    }
    function setPSCID($PSCIDIn) {
          $this->PSCID = $PSCIDIn;
    }

    function getExternalID() {
          return $this->ExternalID;
    }
    function setExternalID($ExternalIDIn) {
          $this->ExternalID = $ExternalIDIn;
    }

    function getDoB() {
          return $this->DoB;
    }
    function setDoB($DoBIn) {
          $this->DoB = $DoBIn;
    }

    function getEDC() {
          return $this->EDC;
    }
    function setEDC($EDCIn) {
          $this->EDC = $EDCIn;
    }

    function getGender() {
          return $this->Gender;
    }
    function setGender($GenderIn) {
          $this->Gender = $GenderIn;
    }

    function getCenterID() {
          return $this->CenterID;
    }
    function setCenterID($CenterIDIn) {
          $this->CenterID = $CenterIDIn;
    }

    function getProjectID() {
          return $this->ProjectID;
    }
    function setProjectID($ProjectIDIn) {
          $this->ProjectID = $ProjectIDIn;
    }

    function getEthnicity() {
          return $this->Ethnicity;
    }
    function setEthnicity($EthnicityIn) {
          $this->Ethnicity = $EthnicityIn;
    }

    function getActive() {
          return $this->Active;
    }
    function setActive($ActiveIn) {
          $this->Active = $ActiveIn;
    }

    function getDate_active() {
          return $this->Date_active;
    }
    function setDate_active($Date_activeIn) {
          $this->Date_active = $Date_activeIn;
    }

    function getRegisteredBy() {
          return $this->RegisteredBy;
    }
    function setRegisteredBy($RegisteredByIn) {
          $this->RegisteredBy = $RegisteredByIn;
    }

    function getUserID() {
          return $this->UserID;
    }
    function setUserID($UserIDIn) {
          $this->UserID = $UserIDIn;
    }

    function getDate_registered() {
          return $this->Date_registered;
    }
    function setDate_registered($Date_registeredIn) {
          $this->Date_registered = $Date_registeredIn;
    }

    function getFlagged_caveatemptor() {
          return $this->flagged_caveatemptor;
    }
    function setFlagged_caveatemptor($flagged_caveatemptorIn) {
          $this->flagged_caveatemptor = $flagged_caveatemptorIn;
    }

    function getFlagged_reason() {
          return $this->flagged_reason;
    }
    function setFlagged_reason($flagged_reasonIn) {
          $this->flagged_reason = $flagged_reasonIn;
    }

    function getFlagged_other() {
          return $this->flagged_other;
    }
    function setFlagged_other($flagged_otherIn) {
          $this->flagged_other = $flagged_otherIn;
    }

    function getFlagged_other_status() {
          return $this->flagged_other_status;
    }
    function setFlagged_other_status($flagged_other_statusIn) {
          $this->flagged_other_status = $flagged_other_statusIn;
    }

    function getTestdate() {
          return $this->Testdate;
    }
    function setTestdate($TestdateIn) {
          $this->Testdate = $TestdateIn;
    }

    function getEntity_type() {
          return $this->Entity_type;
    }
    function setEntity_type($Entity_typeIn) {
          $this->Entity_type = $Entity_typeIn;
    }

    function getProbandGender() {
          return $this->ProbandGender;
    }
    function setProbandGender($ProbandGenderIn) {
          $this->ProbandGender = $ProbandGenderIn;
    }

    function getProbandDoB() {
          return $this->ProbandDoB;
    }
    function setProbandDoB($ProbandDoBIn) {
          $this->ProbandDoB = $ProbandDoBIn;
    }



    /** 
     * setAll allows to set all persistent variables in one method call.
     * This is useful, when all data is available and it is needed to 
     * set the initial state of this object. Note that this method will
     * directly modify instance variales, without going trough the 
     * individual set-methods.
     */

    function setAll($IDIn,
          $CandIDIn,
          $PSCIDIn,
          $ExternalIDIn,
          $DoBIn,
          $EDCIn,
          $GenderIn,
          $CenterIDIn,
          $ProjectIDIn,
          $EthnicityIn,
          $ActiveIn,
          $Date_activeIn,
          $RegisteredByIn,
          $UserIDIn,
          $Date_registeredIn,
          $flagged_caveatemptorIn,
          $flagged_reasonIn,
          $flagged_otherIn,
          $flagged_other_statusIn,
          $TestdateIn,
          $Entity_typeIn,
          $ProbandGenderIn,
          $ProbandDoBIn) {
          $this->ID = $IDIn;
          $this->CandID = $CandIDIn;
          $this->PSCID = $PSCIDIn;
          $this->ExternalID = $ExternalIDIn;
          $this->DoB = $DoBIn;
          $this->EDC = $EDCIn;
          $this->Gender = $GenderIn;
          $this->CenterID = $CenterIDIn;
          $this->ProjectID = $ProjectIDIn;
          $this->Ethnicity = $EthnicityIn;
          $this->Active = $ActiveIn;
          $this->Date_active = $Date_activeIn;
          $this->RegisteredBy = $RegisteredByIn;
          $this->UserID = $UserIDIn;
          $this->Date_registered = $Date_registeredIn;
          $this->flagged_caveatemptor = $flagged_caveatemptorIn;
          $this->flagged_reason = $flagged_reasonIn;
          $this->flagged_other = $flagged_otherIn;
          $this->flagged_other_status = $flagged_other_statusIn;
          $this->Testdate = $TestdateIn;
          $this->Entity_type = $Entity_typeIn;
          $this->ProbandGender = $ProbandGenderIn;
          $this->ProbandDoB = $ProbandDoBIn;
    }


    /** 
     * hasEqualMapping-method will compare two Candidate instances
     * and return true if they contain same values in all persistent instance 
     * variables. If hasEqualMapping returns true, it does not mean the objects
     * are the same instance. However it does mean that in that moment, they 
     * are mapped to the same row in database.
     */
    function hasEqualMapping($valueObject) {

          if ($valueObject->getID() != $this->ID) {
                    return(false);
          }
          if ($valueObject->getCandID() != $this->CandID) {
                    return(false);
          }
          if ($valueObject->getPSCID() != $this->PSCID) {
                    return(false);
          }
          if ($valueObject->getExternalID() != $this->ExternalID) {
                    return(false);
          }
          if ($valueObject->getDoB() != $this->DoB) {
                    return(false);
          }
          if ($valueObject->getEDC() != $this->EDC) {
                    return(false);
          }
          if ($valueObject->getGender() != $this->Gender) {
                    return(false);
          }
          if ($valueObject->getCenterID() != $this->CenterID) {
                    return(false);
          }
          if ($valueObject->getProjectID() != $this->ProjectID) {
                    return(false);
          }
          if ($valueObject->getEthnicity() != $this->Ethnicity) {
                    return(false);
          }
          if ($valueObject->getActive() != $this->Active) {
                    return(false);
          }
          if ($valueObject->getDate_active() != $this->Date_active) {
                    return(false);
          }
          if ($valueObject->getRegisteredBy() != $this->RegisteredBy) {
                    return(false);
          }
          if ($valueObject->getUserID() != $this->UserID) {
                    return(false);
          }
          if ($valueObject->getDate_registered() != $this->Date_registered) {
                    return(false);
          }
          if ($valueObject->getFlagged_caveatemptor() != $this->flagged_caveatemptor) {
                    return(false);
          }
          if ($valueObject->getFlagged_reason() != $this->flagged_reason) {
                    return(false);
          }
          if ($valueObject->getFlagged_other() != $this->flagged_other) {
                    return(false);
          }
          if ($valueObject->getFlagged_other_status() != $this->flagged_other_status) {
                    return(false);
          }
          if ($valueObject->getTestdate() != $this->Testdate) {
                    return(false);
          }
          if ($valueObject->getEntity_type() != $this->Entity_type) {
                    return(false);
          }
          if ($valueObject->getProbandGender() != $this->ProbandGender) {
                    return(false);
          }
          if ($valueObject->getProbandDoB() != $this->ProbandDoB) {
                    return(false);
          }

          return true;
    }



    /**
     * toString will return String object representing the state of this 
     * valueObject. This is useful during application development, and 
     * possibly when application is writing object states in textlog.
     */
    function toString() {
        $out = $this->getDaogenVersion();
        $out = $out."\nclass Candidate, mapping to table Candidate\n";
        $out = $out."Persistent attributes: \n"; 
        $out = $out."ID = ".$this->ID."\n"; 
        $out = $out."CandID = ".$this->CandID."\n"; 
        $out = $out."PSCID = ".$this->PSCID."\n"; 
        $out = $out."ExternalID = ".$this->ExternalID."\n"; 
        $out = $out."DoB = ".$this->DoB."\n"; 
        $out = $out."EDC = ".$this->EDC."\n"; 
        $out = $out."Gender = ".$this->Gender."\n"; 
        $out = $out."CenterID = ".$this->CenterID."\n"; 
        $out = $out."ProjectID = ".$this->ProjectID."\n"; 
        $out = $out."Ethnicity = ".$this->Ethnicity."\n"; 
        $out = $out."Active = ".$this->Active."\n"; 
        $out = $out."Date_active = ".$this->Date_active."\n"; 
        $out = $out."RegisteredBy = ".$this->RegisteredBy."\n"; 
        $out = $out."UserID = ".$this->UserID."\n"; 
        $out = $out."Date_registered = ".$this->Date_registered."\n"; 
        $out = $out."flagged_caveatemptor = ".$this->flagged_caveatemptor."\n"; 
        $out = $out."flagged_reason = ".$this->flagged_reason."\n"; 
        $out = $out."flagged_other = ".$this->flagged_other."\n"; 
        $out = $out."flagged_other_status = ".$this->flagged_other_status."\n"; 
        $out = $out."Testdate = ".$this->Testdate."\n"; 
        $out = $out."Entity_type = ".$this->Entity_type."\n"; 
        $out = $out."ProbandGender = ".$this->ProbandGender."\n"; 
        $out = $out."ProbandDoB = ".$this->ProbandDoB."\n"; 
        return $out;
    }


    /**
     * Clone will return identical deep copy of this valueObject.
     * Note, that this method is different than the clone() which
     * is defined in java.lang.Object. Here, the retuned cloned object
     * will also have all its attributes cloned.
     */
    function clone() {
        $cloned = new Candidate_VO();

        $cloned->setID($this->ID); 
        $cloned->setCandID($this->CandID); 
        $cloned->setPSCID($this->PSCID); 
        $cloned->setExternalID($this->ExternalID); 
        $cloned->setDoB($this->DoB); 
        $cloned->setEDC($this->EDC); 
        $cloned->setGender($this->Gender); 
        $cloned->setCenterID($this->CenterID); 
        $cloned->setProjectID($this->ProjectID); 
        $cloned->setEthnicity($this->Ethnicity); 
        $cloned->setActive($this->Active); 
        $cloned->setDate_active($this->Date_active); 
        $cloned->setRegisteredBy($this->RegisteredBy); 
        $cloned->setUserID($this->UserID); 
        $cloned->setDate_registered($this->Date_registered); 
        $cloned->setFlagged_caveatemptor($this->flagged_caveatemptor); 
        $cloned->setFlagged_reason($this->flagged_reason); 
        $cloned->setFlagged_other($this->flagged_other); 
        $cloned->setFlagged_other_status($this->flagged_other_status); 
        $cloned->setTestdate($this->Testdate); 
        $cloned->setEntity_type($this->Entity_type); 
        $cloned->setProbandGender($this->ProbandGender); 
        $cloned->setProbandDoB($this->ProbandDoB); 

        return $cloned;
    }



    /** 
     * getDaogenVersion will return information about
     * generator which created these sources.
     */
    function getDaogenVersion() {
        return "DaoGen version 2.4.1";
    }

}
