<?php declare(strict_types=1);

/**
 * The module to display study statistics
 *
 * PHP Version 8
 *
 * @category Loris
 * @package  Main
 * @author   Dave MacFarlane <driusan@bic.mni.mcgill.ca>
 * @license  http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link     https://github.com/aces/Loris
 */
namespace LORIS\statistics;
use \Psr\Http\Message\ServerRequestInterface;
use \Psr\Http\Message\ResponseInterface;
use \Psr\Http\Server\RequestHandlerInterface;


/**
 * The module to display study statistics
 *
 * PHP Version 8
 *
 * @category Loris
 * @package  Main
 * @author   Dave MacFarlane <driusan@bic.mni.mcgill.ca>
 * @license  http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link     https://github.com/aces/Loris
 */
class Charts extends \NDB_Page
{
    public $skipTemplate = true;

    /**
     * Checking user's permission
     *
     * @param \User $user The user whose access is being checked
     *
     * @return bool
     */
    function _hasAccess(\User $user) : bool
    {
        return $user->hasPermission('data_entry');
    }

    /**
     * Overrides the parent process function to re-add the application/json header
     * which otherwise sometimes gets removed if the middleware shortcircuits out
     * before calling handle.
     *
     * @param ServerRequestInterface  $request The PSR7 request
     * @param RequestHandlerInterface $handler The handler function
     *
     * @return ResponseInterface the PSR15 response that was generated by the
     * middleware
     */
    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler
    ) : ResponseInterface {
        return parent::process($request, $handler)->withHeader(
            'Content-Type',
            'application/json'
        );
    }

    /**
     * Handle the incoming request.
     *
     * @param ServerRequestInterface $request The incoming PSR7 request
     *
     * @return ResponseInterface
     */
    public function handle(ServerRequestInterface $request) : ResponseInterface
    {
        if ($request->getMethod() !== 'GET') {
            return new \LORIS\Http\Response\JSON\MethodNotAllowed(['GET']);
        }

        // Strip any prefix of '/' to ensure that we don't have an empty string
        // when splitting the path, then there should be exactly 2 parts left,
        // "charts", and the endpoint requested.
        $url = ltrim(
            $request->getAttribute("unhandledURI")->getPath(),
            '/'
        );

        $pathparts = explode('/', $url);
        if (count($pathparts) != 2) {
            return new \LORIS\Http\Response\JSON\NotFound();
        }

        switch ($pathparts[1]) {
        case 'siterecruitment_pie':
            return $this->_handleSitePieData($request);
        case 'agerecruitment_pie':
            return $this->_handleAgePieData($request);
        case 'ethnicity_pie':
            return $this->_handleEthnicityPieData($request);
        case 'siterecruitment_bysex':
            return $this->_handleSiteSexBreakdown($request);
        case 'scans_bymonth':
            return $this->_handleScansByMonth($request);
        case 'siterecruitment_bymonth':
            return $this->_handleSiteLineData($request);
        case 'agedistribution_line':
            return $this->_handleAgeDistributionByProject($request);
        default:
            return new \LORIS\Http\Response\JSON\NotFound();
        }
    }

    /**
     * Handle an incoming request for pie data.
     *
     * @param ServerRequestInterface $request The incoming PSR7 request
     *
     * @return ResponseInterface
     */
    private function _handleSitePieData(ServerRequestInterface $request)
    {
        $DB = \NDB_Factory::singleton()->database();

        $conditions = $this->_buildQueryConditions($request);

        $recruitmentBySiteData = [];

        $user          = \NDB_Factory::singleton()->user();
        $list_of_sites = $user->getStudySites();

        $data = $DB->pselectColWithIndexKey(
            "SELECT COUNT(c.CandID), c.RegistrationCenterID as CenterID
                FROM candidate c
                {$conditions['sessionJoin']}
                {$conditions['participantStatusJoin']}
                WHERE c.Active='Y' AND c.Entity_type='Human'
                {$conditions['projectQuery']}
                {$conditions['cohortQuery']}
                {$conditions['visitQuery']}
                {$conditions['siteQuery']}
                {$conditions['participantStatusQuery']}
                GROUP BY c.RegistrationCenterID",
            $conditions['params'],
            "CenterID"
        );

        foreach ($list_of_sites as $siteID => $siteName) {

            $recruitmentBySiteData[] = [
                "label" => $siteName,
                "total" => intval($data[$siteID] ?? 0),
            ];
        }
        return new \LORIS\Http\Response\JsonResponse($recruitmentBySiteData);
    }

    /**
     * Handle an incoming request for site sex breakdown.
     *
     * @param ServerRequestInterface $request The incoming PSR7 request
     *
     * @return ResponseInterface
     */
    private function _handleSiteSexBreakdown(ServerRequestInterface $request)
    {
        $DB      = \NDB_Factory::singleton()->database();
        $sexData = [];

        $conditions = $this->_buildQueryConditions($request);

        $user          = \NDB_Factory::singleton()->user();
        $list_of_sites = $user->getStudySites();

        $data           = $DB->pselect(
            "
                SELECT COUNT(c.CandID) as Count,
                    c.RegistrationCenterID as SiteID,
                    c.Sex as Sex
                FROM candidate c
                {$conditions['sessionJoin']}
                {$conditions['participantStatusJoin']}
                WHERE c.Active='Y' AND c.Entity_type='Human'
                {$conditions['projectQuery']}
                {$conditions['cohortQuery']}
                {$conditions['visitQuery']}
                {$conditions['siteQuery']}
                {$conditions['participantStatusQuery']}
                GROUP BY c.RegistrationCenterID, c.Sex",
            $conditions['params']
        );
        $processed_data = [];
        foreach ($data as $row) {
            $siteid = $row['SiteID'];
            $count  = intval($row['Count']);
            $sex    = is_string($row['Sex']) ? strtolower($row['Sex']) : '';
            if (!isset($processed_data[$siteid])) {
                $processed_data[$siteid] = [
                    strtolower($sex) => $count
                ];
            } else {
                assert(!isset($processed_data[$siteid][$sex]));
                $processed_data[$siteid][$sex] = $count;
            }
        }
        foreach ($list_of_sites as $siteID => $siteName) {
            $sexData['labels'][] = $siteName;

            $sexData['datasets']['female'][]
                = $processed_data[$siteID]['female'] ?? 0;

            $sexData['datasets']['male'][]
                = $processed_data[$siteID]['male'] ?? 0;
        }

        return (new \LORIS\Http\Response\JsonResponse($sexData));
    }

    /**
     * Handle an incoming request for age pie data.
     *
     * @param ServerRequestInterface $request The incoming PSR7 request
     *
     * @return ResponseInterface
     */
    private function _handleAgePieData(ServerRequestInterface $request)
    {
        $conditions = $this->_buildQueryConditions($request);

        $DB = \NDB_Factory::singleton()->database();

        $dates = $DB->pselect(
            "SELECT DISTINCT c.CandID, c.DoB, c.Date_registered
            FROM candidate c
            {$conditions['sessionJoin']}
            {$conditions['participantStatusJoin']}
            WHERE c.DoB IS NOT NULL
            AND c.Active='Y'
            AND c.Entity_type='Human'
            {$conditions['projectQuery']}
            {$conditions['cohortQuery']}
            {$conditions['visitQuery']}
            {$conditions['siteQuery']}
            {$conditions['participantStatusQuery']}",
            $conditions['params']
        );

        // Initialize an array to store the dynamic age splits
        $ageSplits = [];

        foreach ($dates as $_ => $value) {
            // Note that age is calculated from date registered, not today
            $ageOb = \Utility::calculateAge(
                $value['DoB'],
                $value['Date_registered']
            );
            $age   = $ageOb['year'];

            // Determine the starting point of the age split (a multiple of 5)
            $startOfSplit = intval(floor($age / 5) * 5);

            // Check if the age split already exists in the array
            if (!isset($ageSplits[$startOfSplit])) {
                // If not, create a new entry with the starting age as the key
                $ageSplits[$startOfSplit] = 0;
            }

            // Increment the count for the corresponding age split
            ++$ageSplits[$startOfSplit];
        }

        // Convert the dynamic age splits into the desired format
        $recruitmentByAgeData = [];
        foreach ($ageSplits as $startOfSplit => $count) {
            $endOfSplit = $startOfSplit + 4; // Adjust the age range as needed
            $label      = $startOfSplit . '-' . $endOfSplit;
            $recruitmentByAgeData[] = ["label" => $label, "total" => $count];
        }
        // sort the labels
        usort(
            $recruitmentByAgeData,
            function ($a, $b) {
                return $a['label'] <=> $b['label'];
            }
        );

        return (new \LORIS\Http\Response\JsonResponse($recruitmentByAgeData));
    }

    /**
     * Handle an incoming request for age distribution by project breakdown.
     *
     * @param ServerRequestInterface $request The incoming PSR7 request
     *
     * @return ResponseInterface
     */
    private function _handleAgeDistributionByProject(ServerRequestInterface $request)
    {
        $conditions = $this->_buildQueryConditions($request);
        $user       = \NDB_Factory::singleton()->user();

        $DB = \NDB_Factory::singleton()->database();
        $list_of_projects = $user->getProjects();

        // Sort projects by name
        usort(
            $list_of_projects,
            function ($p1, $p2) {
                return strcmp($p1->getName(), $p2->getName());
            }
        );

        $ages_per_project = $DB->pselect(
            "SELECT p.ProjectID, p.Name as ProjectName, c.DoB, c.Date_registered
            FROM candidate c
            {$conditions['sessionJoin']}
            {$conditions['participantStatusJoin']}
            JOIN Project p ON p.ProjectID=c.RegistrationProjectID
            WHERE c.DoB IS NOT NULL
            AND c.Active='Y'
            AND c.Entity_type='Human'
            {$conditions['projectQuery']}
            {$conditions['cohortQuery']}
            {$conditions['visitQuery']}
            {$conditions['siteQuery']}
            {$conditions['participantStatusQuery']}",
            $conditions['params']
        );

        // Initialize age distribution data
        $ageData = [];
        $allAges = [];

        // Process age data by project
        $agesByProject = [];
        foreach ($ages_per_project as $row) {
            $projectID = $row['ProjectID'];
            $agesByProject[$projectID]['name'] = $row['ProjectName'];

            // Calculate age from date registered
            $ageOb = \Utility::calculateAge(
                $row['DoB'],
                $row['Date_registered']
            );
            $age   = $ageOb['year'];

            // Track all ages for labels
            $allAges[$age] = true;

            if (!isset($agesByProject[$projectID]['ages'])) {
                $agesByProject[$projectID]['ages'] = [];
            }
            if (!isset($agesByProject[$projectID]['ages'][$age])) {
                $agesByProject[$projectID]['ages'][$age] = 1;
            } else {
                $agesByProject[$projectID]['ages'][$age]++;
            }
        }

        // Create sorted labels (individual ages)
        $ageLabels = array_keys($allAges);
        sort($ageLabels, SORT_NUMERIC);

        $ageData['labels'] = $ageLabels;

        // Format data for each project
        $ageData['datasets'] = [];
        foreach ($agesByProject as $projectData) {
            $data = [];
            foreach ($ageLabels as $age) {
                $data[] = $projectData['ages'][$age] ?? 0;
            }

            $ageData['datasets'][] = [
                'name' => $projectData['name'],
                'data' => $data
            ];
        }

        return new \LORIS\Http\Response\JsonResponse($ageData);
    }

    /**
     * Handle an incoming request for ethnicity pie data.
     *
     * @param ServerRequestInterface $request The incoming PSR7 request
     *
     * @return ResponseInterface
     */
    private function _handleEthnicityPieData(ServerRequestInterface $request)
    {
        $conditions = $this->_buildQueryConditions($request);

        $DB = \NDB_Factory::singleton()->database();

        $candidates = $DB->pselect(
            "SELECT DISTINCT c.CandID, c.Ethnicity
            FROM candidate c
            {$conditions['sessionJoin']}
            {$conditions['participantStatusJoin']}
            WHERE c.Active='Y'
            AND c.Entity_type='Human'
            {$conditions['projectQuery']}
            {$conditions['cohortQuery']}
            {$conditions['visitQuery']}
            {$conditions['siteQuery']}
            {$conditions['participantStatusQuery']}",
            $conditions['params']
        );

        // Initialize an array to store the ethnicities
        $ethnicities = [];

        foreach ($candidates as $_ => $value) {
            // Check if the ethnicity already exists in the array
            if (!isset($ethnicities[$value["Ethnicity"]])) {
                // If not, create a new entry with the ethnicity as the key
                $ethnicities[$value["Ethnicity"]] = 0;
            }

            // Increment the count for the corresponding ethnicity
            ++$ethnicities[$value["Ethnicity"]];
        }

        // Convert into the desired format
        $recruitmentByEthnicityData = [];
        foreach ($ethnicities as $id => $count) {
            $id = str_replace("_", " ", $id);
            $id = strtolower($id);
            $id = ucwords($id);
            if ($id == null) {
                $id = dgettext("statistics", "Unknown");
            }
            $label = $id;
            $recruitmentByEthnicityData[] = ["label" => $label, "total" => $count];
        }

        return (new \LORIS\Http\Response\JsonResponse($recruitmentByEthnicityData));
    }

    /**
     * Handle an incoming request for monthly progression
     *
     * @param ServerRequestInterface $request The incoming PSR7 request
     *
     * @return ResponseInterface
     */
    private function _handleScansByMonth(ServerRequestInterface $request)
    {
        $DB = \NDB_Factory::singleton()->database();

        $conditions = $this->_buildQueryConditions($request, true);

        $user          = \NDB_Factory::singleton()->user();
        $list_of_sites = $user->getStudySites();

        $scanData = [];
        // Run a query to get all the data. Order matters to ensure that the
        // labels are calculated in the correct order.
        $data = iterator_to_array(
            $DB->pselect(
                "SELECT s.CenterID,
                CONCAT(MONTH(pf.Value), '-', YEAR(pf.Value)) as datelabel,
                COUNT(distinct s.ID) as count
            FROM files f
            LEFT JOIN parameter_file pf USING (FileID)
            LEFT JOIN session s ON (s.ID=f.SessionID)
            {$conditions['candJoin']}
            {$conditions['participantStatusJoin']}
            JOIN parameter_type pt USING (ParameterTypeID)
            WHERE pt.Name='acquisition_date'
            {$conditions['projectQuery']}
            {$conditions['cohortQuery']}
            {$conditions['visitQuery']}
            {$conditions['siteQuery']}
            {$conditions['participantStatusQuery']}
            GROUP BY MONTH(pf.Value), YEAR(pf.Value), s.CenterID, datelabel
            ORDER BY YEAR(pf.Value), MONTH(pf.Value), s.CenterID",
                $conditions['params']
            )
        );

        // TODO: make this work as bar data
        // Create the labels.
        //
        // We want to ensure that every month label appear exactly once and
        // in order, but the same label may appear multiple times across different
        // sites. Since the query was ordered, we use a new associative array
        // of labels and set the keys to to an arbitrary value (true) in order to
        // strip out duplicates, then take the keys of the resulting array once
        // done. The result should be an ordered numeric array with each label
        // for the chart in it exactly once.
        $labels = [];
        foreach ($data as $row) {
            $labels[$row['datelabel']] = true;
        }
        $scanData['labels'] = array_keys($labels);

        // Massage the data into the appropriate format per site.
        foreach ($list_of_sites as $siteID => $siteName) {
            $scanData['datasets'][] = [
                "name" => $siteName,
                "data" => $this->_getScansPerMonthData(
                    $data,
                    $siteID,
                    $scanData['labels']
                )
            ];
        }
        return (new \LORIS\Http\Response\JsonResponse($scanData));
    }

    /**
     * Helper to get the scans per month data in the correct format for a
     * given site
     *
     * @param array $data   The data for all sites.
     * @param int   $siteID The site to get the monthly data for.
     * @param array $labels An array of all valid labels. (Note that not
     *                      all labels may have data in $data, in which
     *                      case this function must include a "0" to maintain
     *                      order.)
     *
     * @return array An indexed array of data for site in the order of $labels
     */
    private function _getScansPerMonthData(
        array $data,
        int $siteID,
        array $labels
    ) : array {
        $sitedata   = array_filter(
            $data,
            function ($row) use ($siteID) {
                return $row['CenterID'] == $siteID;
            }
        );
        $mappeddata = [];
        foreach ($sitedata as $row) {
            $mappeddata[$row['datelabel']] = $row['count'];
        }

        $data = [];
        foreach ($labels as $i => $label) {
            $data[$i] = $mappeddata[$label] ?? 0;
        }
        return $data;
    }

    /**
     * Helper to handle the siterecruitment_line endpoint.
     *
     * @param ServerRequestInterface $request The incoming PSR7 request
     *
     * @return ResponseInterface
     */
    private function _handleSiteLineData(ServerRequestInterface $request)
    {
        $DB = \NDB_Factory::singleton()->database();

        $conditions = $this->_buildQueryConditions($request, false);

        $recruitmentData      = [];
        $recruitmentStartDate = $DB->pselectOne(
            "SELECT MIN(Date_registered) FROM candidate",
            []
        );
        $recruitmentEndDate   = $DB->pselectOne(
            "SELECT MAX(Date_registered) FROM candidate",
            []
        );

        if ($recruitmentStartDate !== null
            && $recruitmentEndDate !== null
        ) {
            $recruitmentData['labels'] = $this->_createSiteLineChartLabels(
                new \DateTimeImmutable($recruitmentStartDate),
                new \DateTimeImmutable($recruitmentEndDate)
            );
        }

        $user          = \NDB_Factory::singleton()->user();
        $list_of_sites = $user->getStudySites();

        $recruitment_summary = $DB->pselect(
            "SELECT COUNT(c.CandID) as Count,
            MONTH(c.Date_registered) as Month,
            YEAR(c.Date_registered) as Year,
            c.RegistrationCenterID as SiteID
                FROM candidate c
                {$conditions['participantStatusJoin']}
                {$conditions['sessionJoin']}
                    WHERE c.Entity_type='Human'
                    {$conditions['projectQuery']}
                    {$conditions['cohortQuery']}
                    {$conditions['visitQuery']}
                    {$conditions['siteQuery']}
                    {$conditions['participantStatusQuery']}
                GROUP BY MONTH(c.Date_registered),
                    YEAR(c.Date_registered),
                    c.RegistrationCenterID",
            $conditions['params']
        );

        $recruitmentdata = [];
        foreach ($recruitment_summary as $row) {
            $siteId = $row['SiteID'];
            $year   = $row['Year'];
            $month  = $row['Month'];
            if (!isset($recruitmentdata[$siteId])) {
                $recruitmentdata[$siteId] = [
                    $year => [$month => $row['Count']]
                ];
            } else if (!isset($recruitmentdata[$siteId][$year])) {
                $recruitmentdata[$siteId][$year] = [$month => $row['Count']];
            } else {
                assert(!isset($recruitmentdata[$siteId][$year][$month]));
                $recruitmentdata[$siteId][$year][$month] = $row['Count'];
            }

        }
        foreach ($list_of_sites as $siteID => $siteName) {
            if (!isset($recruitmentData['labels'])) {
                continue;
            }
            $recruitmentData['datasets'][] = [
                "name" => $siteName,
                "data" => $this->_getSiteLineRecruitmentData(
                    $siteID,
                    $recruitmentData['labels'],
                    $recruitmentdata,
                ),
            ];
        }
        return new \LORIS\Http\Response\JsonResponse($recruitmentData);
    }

    /**
     * Helper to generate query conditions for for incoming requests.
     *
     * @param ServerRequestInterface $request      The incoming PSR7 request
     * @param bool                   $scansbymonth Whether or not the
     *                                             request is for scans by month.
     *
     * @return array
     */
    private function _buildQueryConditions(
        ServerRequestInterface $request,
        $scansbymonth = false
    ) {
        $user        = \NDB_Factory::singleton()->user();
        $queryParams = $request->getQueryParams();

        $cohortQuery = '';
        $sessionJoin = '';
        $visitQuery  = '';
        $PSJoin      = '';
        $candJoin    = '';
        $participantStatusQuery = '';
        $params       = [];
        $paramCounter = 0;

        /**
         * Helper function to generate parameterized IN clause
         */
        $generateInClause = function ($values) use (&$params, &$paramCounter) {
            $placeholders = [];
            $valueArray   = explode(',', $values);
            foreach ($valueArray as $value) {
                $paramName          = 'param' . (++$paramCounter);
                $placeholders[]     = ':' . $paramName;
                $params[$paramName] = trim($value);
            }
            return '(' . implode(',', $placeholders) . ')';
        };

        if (($queryParams['selectedProjects'] ?? "undefined") != 'undefined') {
            if ($scansbymonth === true) {
                $projectQuery = " AND s.ProjectID IN "
                    . $generateInClause($queryParams['selectedProjects']);
            } else {
                $candJoin     = "JOIN candidate c ON c.ID=s.CandidateID";
                $projectQuery = " AND c.RegistrationProjectID IN "
                    . $generateInClause($queryParams['selectedProjects']);
            }
        } else {
            $userProjects        = $user->getProjectIDs();
            $projectPlaceholders = [];
            foreach ($userProjects as $projectId) {
                $paramName = 'userProject' . (++$paramCounter);
                $projectPlaceholders[] = ':' . $paramName;
                // Extract the actual ID value from the ProjectID object
                $params[$paramName] = $projectId->__toString();
            }
            if ($scansbymonth === true) {
                $projectQuery = " AND s.ProjectID IN ("
                    . implode(',', $projectPlaceholders) . ") ";
                $sessionJoin  = "JOIN session s ON s.CandidateID=c.ID";
            } else {
                $projectQuery = " AND c.RegistrationProjectID IN ("
                    . implode(',', $projectPlaceholders) . ") ";
            }
        }

        if (($queryParams['selectedCohorts'] ?? "undefined") != 'undefined') {
            $cohortQuery = " AND s.CohortID IN "
                . $generateInClause($queryParams['selectedCohorts']) . " ";
            $sessionJoin = "JOIN session s ON s.CandidateID=c.ID";
        }

        if (($queryParams['selectedSites'] ?? "undefined") != 'undefined') {
            // Set site query if selected
            if ($scansbymonth === true) {
                $siteQuery = " AND s.CenterID IN "
                    . $generateInClause($queryParams['selectedSites']) . " ";
            } else {
                $siteQuery = " AND c.RegistrationCenterID IN "
                    . $generateInClause($queryParams['selectedSites']) . " ";
            }
        } else {
            // If not selected, only take user sites
            $centerIDs          = $user->getCenterIDs();
            $centerPlaceholders = [];
            foreach ($centerIDs as $centerId) {
                $paramName            = 'userCenter' . (++$paramCounter);
                $centerPlaceholders[] = ':' . $paramName;
                // Extract the actual ID value from the CenterID object
                $params[$paramName] = $centerId->__toString();
            }
            if ($scansbymonth === true) {
                $siteQuery = " AND s.CenterID IN ("
                    . implode(',', $centerPlaceholders) . ") ";
            } else {
                $siteQuery = " AND c.RegistrationCenterID IN ("
                    . implode(',', $centerPlaceholders) . ") ";
            }
        }

        if (($queryParams['selectedVisits'] ?? "undefined") != 'undefined') {
            // Set visit query if visits selected
            $visitQuery  = " AND s.Visit_label IN "
                . $generateInClause($queryParams['selectedVisits']) . " ";
            $sessionJoin = "JOIN session s ON s.CandidateID=c.ID";
        }
        if (($queryParams['selectedParticipantStatus'] ?? "undefined") != 'undefined'
        ) {
            $candJoin = "JOIN candidate c ON c.ID=s.CandidateID";
            $PSJoin   = 'LEFT JOIN participant_status ps ON c.ID=ps.CandidateID';
            // Null participant status counts as Active because
            // sometimes users do not update the participant_status tab
            if (str_contains($queryParams['selectedParticipantStatus'] ?? '', '1')) {
                $participantStatusQuery = " AND (
                    ps.participant_status IN " .
                    $generateInClause($queryParams['selectedParticipantStatus'])
                    . " OR ps.participant_status IS NULL
                )";
            } else {
                $participantStatusQuery = " AND ps.participant_status IN " .
                $generateInClause($queryParams['selectedParticipantStatus']) . " ";
            }
        }

        if (($queryParams['dateRegisteredStart'] ?? "undefined") != 'undefined') {
            $candJoin           = "JOIN candidate c ON c.ID=s.CandidateID";
            $paramName          = 'dateStart' . (++$paramCounter);
            $projectQuery      .= " AND c.Date_registered >= :$paramName";
            $params[$paramName] = $queryParams['dateRegisteredStart'];
        }
        if (($queryParams['dateRegisteredEnd'] ?? "undefined") != 'undefined') {
            $candJoin           = "JOIN candidate c ON c.ID=s.CandidateID";
            $paramName          = 'dateEnd' . (++$paramCounter);
            $projectQuery      .= " AND c.Date_registered <= :$paramName";
            $params[$paramName] = $queryParams['dateRegisteredEnd'];
        }

        return [
            'projectQuery'           => $projectQuery,
            'cohortQuery'            => $cohortQuery,
            'sessionJoin'            => $sessionJoin,
            'visitQuery'             => $visitQuery,
            'siteQuery'              => $siteQuery,
            'participantStatusJoin'  => $PSJoin,
            'participantStatusQuery' => $participantStatusQuery,
            'candJoin'               => $candJoin,
            'params'                 => $params,
        ];
    }

    /**
     * Helper to generate labels for every month between startDate and endDate.
     *
     * @param \DateTimeImmutable $startDate The start date for the labels.
     * @param \DateTimeImmutable $endDate   The end date for the labels.
     *
     * @return array
     */
    private function _createSiteLineChartLabels(
        \DateTimeImmutable $startDate,
        \DateTimeImmutable $endDate
    ) : array {
        $month = date_interval_create_from_date_string('1 month');

        // Since we're only concerned with months, act as if $startDate
        // is always the first of the month so that the last month doesn't
        // get truncated.
        $betweenDate = new \DateTimeImmutable($startDate->format('Y-m-01'));

        $labels = [];

        while ($betweenDate <= $endDate) {
            $labels[]    = $betweenDate->format('n-Y');
            $betweenDate = $betweenDate->add($month);
        }
        return $labels;
    }

    /**
     * Helper to generate the data for the site recruitment line for $siteID.
     *
     * @param int   $siteID          The centerID to get data for.
     * @param array $labels          The list of labels on the chart to fill
     *                               the data for.
     * @param array $recruitmentdata The raw recruitment data to split according to
                                     the labels
     *
     * @return array
     */
    private function _getSiteLineRecruitmentData($siteID, $labels, $recruitmentdata)
    {
        $data = [];
        foreach ($labels as $label) {
            $month  = (strlen($label) == 6)
                ? substr($label, 0, 1) : substr($label, 0, 2);
            $year   = substr($label, -4, 4);
            $data[] = intval($recruitmentdata[$siteID][$year][$month] ?? "0");
        }
        return $data;
    }
}
