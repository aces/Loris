<?php declare(strict_types=1);
/**
 * This script is designed to work with the dataExtractor tool to push data into
 * an Open Science LORIS instance. 
 *
 * After data has been extracted by the other tool,
 * this script will take as input that data dump (in CSV format) as well as a 
 * mapping file of PSCIDs from the source study to new PSCIDs in the Open 
 * Science database. This mapping file must be kept local and private. 
 *
 * This tool will link the two CSV files by comparing the old PSCIDs and
 * generate SQL statements needed to add the source data into the open database.
 * TODO Optionally this script will automatically run the commands on behalf
 * of the user.
 *
 * This script relies heavily on the column layout of the two CSV files. Old PSCIDs
 * from the source file must be in the left-most column of each file. Further
 * structural requirements are described in the @var annotations for the constants
 * below.
 *
 * @category Tools
 * @package  Open Science
 * @author   John Saigle <john.saigle@mcin.ca>
 * @license  http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link     https://www.github.com/aces/Loris
 */

/**
 * Minimum number of arguments needed to run this script.
 *
 * @var int
 */
const NUM_ARGS_REQUIRED = 4;

/*
 * Expected indices of parameters passed to this script via $argv
 *
 * @var int
 */
const MAPPING_ARG_INDEX = 2;
const DATA_ARG_INDEX = 3;

/**
 * These constants represent the indices of columns within the mapping file.
 * The file passed must have the headers organized in this order. 
 * The names of the columns in the csv file don't matter as long as they are formatted
 * like this.
 *
 *
 * Format:
 *      OLD_PSCID,NEW_PSCID,NEW_CANDID
 *
 * @var int
 */
const OLD_PSCID = 0;
const NEW_PSCID = 1;
const NEW_CANDID = 2;

/**
 * The DATA file passed must have the headers organized in this order. This
 * file is generated by running the dataImporter tool. 
 * The CSV header COLUMN_NAME MUST match the source and destination column 
 * name in the MySQL database as this is how the script determines where the 
 * data should be updated.
 * COLUMN_NAME contains the data from the source database.
 *
 * Format:
 *      OLD_PSCID,COLUMN_NAME
 *
 * @var int
 */
const COLUMN_NAME = 1;

/**
 * These constants are used to make SQL command output more clear.
 *
 * @var int
 */
const SET_COLUMN = 0;
const SET_NEWVALUE = 1;
const WHERE_COLUMN = 0;
const WHERE_OLDVALUE = 1;

/**
 * Command line argument for the mode of data importation.
 */
const COLUMN_IMPORT = 'column';
const VISIT_IMPORT = 'visits';

require_once 'generic_includes.php';

$usage = <<<USAGE
Usage: 

To import a single field from a table:
php {$argv[0]} %s <mapping.csv> <data.csv>
    <mapping.csv>   A CSV file containg columns with OLDPSCID, NEWPSCID, and
                    NEWCANDID
    <data.csv>      A CSV file containing columns with OLDPSCID,DATA

To import visit labels:
php {$argv[0]} %s <mapping.csv> <visits.csv> [excluded.csv]
    <mapping.csv>   A CSV file containg columns with OLDPSCID, NEWPSCID, and
                    NEWCANDID
    <visits.csv>      A CSV file containing information from the 'session' table.
                    Generated by dataExtractor.
    [excluded.txt]  Optional. A file containing PSCIDs whose visits should not
                    be imported. One PSCID per line. 
        
 
USAGE;


/* BEGIN SCRIPT */

// Die if not enough arguments.
if (count($argv) < NUM_ARGS_REQUIRED) {
    die (sprintf($usage, COLUMN_IMPORT, VISIT_IMPORT));
}

// Die if invalid execution mode supplied.
$mode = $argv[1];
if ($mode !== COLUMN_IMPORT && $mode !== VISIT_IMPORT) {
    die (sprintf($usage, COLUMN_IMPORT, VISIT_IMPORT));
}

// Get data from CSV files.
$mappingRows = populateArrayFromCSV($argv[MAPPING_ARG_INDEX]);
$dataRows = populateArrayFromCSV($argv[DATA_ARG_INDEX]);

// Creating this array allows referencing the columns by index. This allows the
// use of name constants to access the data from within the CSV files instead
// of hard-coding column names into this script.
$mappingHeaders = array_keys($mappingRows[0]);
$dataHeaders = array_keys($dataRows[0]);

// Find all the candidates present in both the data file and the mapping file by
// doing a set intersection on the list of old PSCIDs. 
// It's more efficient to do this once before iterating over every data row 
// rather than checking if a PSCID exists in both arrays on each iteration of 
// the data.csv file.
$oldPSCIDsInMappingFile = array();
$oldPSCIDsInDataFile = array();
foreach($mappingRows as $row) {
    $oldPSCIDsInMappingFile[] = $row[$mappingHeaders[OLD_PSCID]];
}
foreach($dataRows as $row) {
    $oldPSCIDsInDataFile[] = $row[$dataHeaders[OLD_PSCID]];
}
// array_intersect preserves keys but we don't want them.
$sharedCandidates = array_values(
    array_intersect($oldPSCIDsInMappingFile, $oldPSCIDsInDataFile)
);

if (count($sharedCandidates) < 1) {
    die(
        'No shared candidates in mapping file and data file. Nothing to update.'
        . PHP_EOL
    );
}

echo sprintf(
    "Found %s PSCID(s) in common between mapping file %s and data file %s\n",
    count($sharedCandidates),
    $argv[MAPPING_ARG_INDEX],
    $argv[DATA_ARG_INDEX]
);

// Build a one-to-one mapping of old to new PSCIDs with the old IDs as the key.
$PSCIDMapping = array();
foreach($mappingRows as $row) {
    $oldPSCID = $row[$mappingHeaders[OLD_PSCID]];
    $newPSCID = $row[$mappingHeaders[NEW_PSCID]];
    $PSCIDMapping[$oldPSCID] = $newPSCID;
}

// The session table uses CandIDs so a mapping from PSCIDs to CandIDs must be
// generated in order to update this table.
// Create a mapping of PSCIDs to CandIDs to allow for direct lookup of a CandID
// given a PSCID. It is more efficient to use this dictionary than searching the
// CSV rows for a CandID each time we need one.
if ($mode === VISIT_IMPORT) {
    $candIDMapping = array();
    foreach ($mappingRows as $row) {
        $newPSCID = $row[$mappingHeaders[NEW_PSCID]];
        $newCandID = $row[$mappingHeaders[NEW_CANDID]];
        $candIDMapping[$newPSCID] = $newCandID;
    }
}

// Prepare the table name and column names to be updated.
switch ($mode) {
case COLUMN_IMPORT:
    // The name of the column to update.
    // NOTE For now only the candidate table is supported.
    $table = 'candidate';
    $dataColumn = $dataHeaders[COLUMN_NAME];
    break;
case VISIT_IMPORT:
    // Visit label information is found in the session table.
    $table = 'session';
    // A string of all the column names to update.
    $setColumns = implode(',', $dataHeaders);
}
    
// Create a queue of commands to execute or print depending on the operation
// mode of the script
$commandQueue = array();

// Iterate over every shared candidate. Then generate the necessary UPDATE 
// command needed to add the COLUMN data from the data file into the new DB.
//
// Iterating over every row in the CSV file instead of the list of PSCIDs
// enables this loop to operate with O(n) time. Iterating over PSCIDs does not
// allow for direct lookup of data cells as the CSV file must be searched each
// time for the PSCID. This results in O(n^2) execution time. To avoid this
// problem the PSCID mapping has been created above.
foreach ($dataRows as $row) {
    // Get the old PSCID. Should always be in the column at index 0.
    $oldPSCID = $row[$dataHeaders[OLD_PSCID]];
    
    // Skip candidates not present in mapping file.
    if (!in_array($oldPSCID, $sharedCandidates, true)) {
        continue;
    }

    $newPSCID = $PSCIDMapping[$oldPSCID];

    // Populate the data for the MySQL command to be output/run by this script,
    // including table name, SET, and WHERE data.
    switch ($mode) {
    case COLUMN_IMPORT:

        // Retrive the cell containing the new data for this candidate.
        $data = $row[$dataColumn];
        $where = array('PSCID', $newPSCID);
        break;
    case VISIT_IMPORT:
        $data = $row;
        // We don't want PSCID information from the CSV file included in the
        // SET statement. It's only used for linking.
        unset($data['PSCID']);
        $where = array('CandID', $candIDMapping[$newPSCID]);
        break;
    }

    $commandQueue[] = array(
        'table' => $table,
        'data' => $data,
        'where' => $where
    );
}

// Format commands for printing.
$report = array();
foreach ($commandQueue as $command) {
    $formattedCommand = <<<SQL
UPDATE {$command["table"]}
SET %s
WHERE {$command['where'][WHERE_COLUMN]} = '{$command['where'][WHERE_OLDVALUE]}';

SQL;
    $setString = array();
    // Iterate over all columns and create a formatted string. Will only be one
    // column for COLUMN_IMPORT mode but several for VISIT_IMPORT.
    foreach ($command['data'] as $column => $value) {
        $setString[] = "$column = '$value'";
    }
    // Interpolate the $setString into the SQL heredoc above and add it to the
    // final $report output.
    $report[] = sprintf($formattedCommand, implode(', ', $setString));
}

// Print report.
print implode(PHP_EOL, $report);


// Converts a csv file into a two-dimensional PHP array where each element
// contains an associative array of the column names and the values.
//
// e.g. file.csv:
//
//      oldPSCID,newPSCID,newCandID
//      MON001,MON999,123456
//      ...
//
// becomes:
// [0] => Array (
//     [oldPSCID] => MON001,
//     [newPSCID] => MON999,
//     [newCandID] => 123456
// ),
// ...
//
// @throws InvalidArgumentException If no data in files or if they're inaccessible
//
// @return array The contents of the CSV file loaded into an associative array.
//
function populateArrayFromCSV(string $filename): array {
    $data = csvToArray($filename);
    if (count($data) < 1) {
        throw new InvalidArgumentException(
            "No CSV data found in $filename" . PHP_EOL
        );
    }
    return $data;
}

/**
 * Convert a comma separated file into an associated array.
 * The first row should contain the array keys.
 *
 * Example:
 *
 * @param string $filename Path to the CSV file
 * @param string $delimiter The separator used in the file
 * @return array
 * @link http://gist.github.com/385876
 * @author Jay Williams <http://myd3.com/>
 * @copyright Copyright (c) 2010, Jay Williams
 * @license http://www.opensource.org/licenses/mit-license.php MIT License
 */
function csvToArray(string $filename='', string $delimiter=','): array
{
	if(!file_exists($filename) || !is_readable($filename))
		return array();

	$header = null;
	$data = array();
	if (($handle = fopen($filename, 'r')) !== FALSE)
	{
		while (($row = fgetcsv($handle, 1000, $delimiter)) !== FALSE)
		{
			if(!$header)
				$header = $row;
			else
				$data[] = array_combine($header, $row);
		}
		fclose($handle);
	}
	return $data;
}
