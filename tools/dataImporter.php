<?php declare(strict_types=1);
/**
 * This script is designed to work with the dataExtractor tool to push data into
 * an Open Science LORIS instance. 
 *
 * After data has been extracted by the other tool,
 * this script will take as input that data dump (in CSV format) as well as a 
 * mapping file of PSCIDs from the source study to new PSCIDs in the Open 
 * Science database. This mapping file must be kept local and private. 
 *
 * This tool will link the two CSV files by comparing the old PSCIDs and
 * generate SQL statements needed to add the source data into the open database.
 * TODO Optionally this script will automatically run the commands on behalf
 * of the user.
 *
 * This script relies heavily on the column layout of the two CSV files. Old PSCIDs
 * from the source file must be in the left-most column of each file. Further
 * structural requirements are described in the @var annotations for the constants
 * below.
 *
 * @category Tools
 * @package  Open Science
 * @author   John Saigle <john.saigle@mcin.ca>
 * @license  http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link     https://www.github.com/aces/Loris
 */

/**
 * Minimum number of arguments needed to run this script.
 *
 * @var int
 */
const NUM_ARGS_REQUIRED = 3;

/*
 * Expected indices of parameters passed to this script via $argv
 *
 * @var int
 */
const MAPPING_ARG_INDEX = 1;
const DATA_ARG_INDEX = 2;

/**
 * These constants represent the indices of columns within the mapping file.
 * The file passed must have the headers organized in this order. 
 * The names of the columns in the csv file don't matter as long as they are formatted
 * like this.
 *
 *
 * Format:
 *      OLD_PSCID,NEW_PSCID,NEW_CANDID
 *
 * @var int
 */
const OLD_PSCID = 0;
const NEW_PSCID = 1;
const NEW_CANDID = 2;

/**
 * The DATA file passed must have the headers organized in this order. This
 * file is generated by running the dataImporter tool. 
 * The CSV header COLUMN_NAME MUST match the source and destination column 
 * name in the MySQL database as this is how the script determines where the 
 * data should be updated.
 * COLUMN_NAME contains the data from the source database.
 *
 * Format:
 *      OLD_PSCID,COLUMN_NAME
 *
 * @var int
 */
const COLUMN_NAME = 1;

/**
 * These constants are used to make SQL command output more clear.
 *
 * @var int
 */
const SET_COLUMN = 0;
const SET_NEWVALUE = 1;
const WHERE_COLUMN = 0;
const WHERE_OLDVALUE = 1;

require_once "generic_includes.php";

$usage = <<<USAGE
Usage: php {$argv[0]} <mapping.csv> <data.csv>
<mapping.csv>   A CSV file containg columns with OLDPSCID, NEWPSCID, and
                NEWCANDID
<data.csv>      A CSV file containing columns with OLDPSCID,DATA
USAGE;


/* BEGIN SCRIPT */

// Die if not enough arguments
if (count($argv) < NUM_ARGS_REQUIRED) {
    die ($usage);
}

// Get data from CSV files.
$mappingRows = populateArrayFromCSV($argv[MAPPING_ARG_INDEX]);
$dataRows = populateArrayFromCSV($argv[DATA_ARG_INDEX]);

// Creating this array allows referencing the columns by index. This allows the
// use of name constants to access the data from within the CSV files instead
// of hard-coding column names into this script.
$mappingHeaders = array_keys($mappingRows[0]);
$dataHeaders = array_keys($dataRows[0]);

// Find all the candidates present in both the data file and the mapping file by
// doing a set intersection on the list of old PSCIDs. 
// It's more efficient to do this once before iterating over every data row 
// rather than checking if a CandID exists in both arrays on each iteration of 
// the data.csv file.
$oldPSCIDsInMappingFile = array();
$oldPSCIDsInDataFile = array();
foreach($mappingRows as $row) {
    $oldPSCIDsInMappingFile[] = $row[$mappingHeaders[OLD_PSCID]];
}
foreach($dataRows as $row) {
    $oldPSCIDsInDataFile[] = $row[$dataHeaders[OLD_PSCID]];
}
// array_intersect preserves keys but we don't want them.
$sharedCandidates = array_values(
    array_intersect($oldPSCIDsInMappingFile, $oldPSCIDsInDataFile)
);

// Build a one-to-one mapping of old to new PSCIDs with the old IDs as the key.
$PSCIDMapping = array();
foreach($mappingRows as $row) {
    $oldPSCID = $row[$mappingHeaders[OLD_PSCID]];
    $newPSCID = $row[$mappingHeaders[NEW_PSCID]];
    $PSCIDMapping[$oldPSCID] = $newPSCID;
}

// The name of the column to update in the MySQL table. Also the header for the
// column in the data.csv file containing the data to insert into the database.
$dataColumn = $dataHeaders[COLUMN_NAME];
    
// Create a queue of commands to execute or print depending on the operation
// mode of the script
$commandQueue = array();

// Iterate over every shared candidate. Then generate the necessary UPDATE 
// command needed to add the COLUMN data from the data file into the new DB.
foreach ($dataRows as $row) {
    $oldPSCID = $row[$dataHeaders[OLD_PSCID]];
    
    // Skip candidates not present in mapping file.
    if (!in_array($oldPSCID, $sharedCandidates, true)) {
        continue;
    }

    $newPSCID = $PSCIDMapping[$oldPSCID];

    // Retrive the cell containing the new data for this candidate.
    $data = $row[$dataColumn];

    // Build the MySQL command that must be executed.
    // NOTE For now only the candidate table is supported.
    $table = 'candidate';
    $set = array($dataColumn, $data);
    $where = array('PSCID', $newPSCID);

    $commandQueue[] = array(
        'table' => $table,
        'set' => $set,
        'where' => $where
    );
    // CommentIDs in the session and flad table need to be updated. The
    // structure of a CommentID is such that it will always begin with the
    // CandID concatenated with the PSCID. We can replace this value with the
    // new IDs.
}

// Format commands for printing.
foreach ($commandQueue as $command) {
    $report[] = <<<SQL
UPDATE {$command["table"]}
SET {$command["set"][SET_COLUMN]} = '{$command["set"][SET_NEWVALUE]}' 
WHERE {$command['where'][WHERE_COLUMN]} = '{$command['where'][WHERE_OLDVALUE]}';

SQL;
}

// Print report.
print implode(PHP_EOL, $report);


// Converts a csv file into a two-dimensional PHP array where each element
// contains an associative array of the column names and the values.
//
// e.g. file.csv:
//
//      oldPSCID,newPSCID,newCandID
//      MON001,MON999,123456
//      ...
//
// becomes:
// [0] => Array (
//     [oldPSCID] => MON001,
//     [newPSCID] => MON999,
//     [newCandID] => 123456
// ),
// ...
//
// @throws InvalidArgumentException If no data in files or if they're inaccessible
//
// @return array The contents of the CSV file loaded into an associative array.
//
function populateArrayFromCSV(string $filename): array {
    $data = csvToArray($filename);
    if (count($data) < 1) {
        throw new InvalidArumentException(
            "No CSV data found in $filename" . PHP_EOL
        );
    }
    return $data;
}

/**
 * Convert a comma separated file into an associated array.
 * The first row should contain the array keys.
 *
 * Example:
 *
 * @param string $filename Path to the CSV file
 * @param string $delimiter The separator used in the file
 * @return array
 * @link http://gist.github.com/385876
 * @author Jay Williams <http://myd3.com/>
 * @copyright Copyright (c) 2010, Jay Williams
 * @license http://www.opensource.org/licenses/mit-license.php MIT License
 */
function csvToArray(string $filename='', string $delimiter=','): array
{
	if(!file_exists($filename) || !is_readable($filename))
		return array();

	$header = null;
	$data = array();
	if (($handle = fopen($filename, 'r')) !== FALSE)
	{
		while (($row = fgetcsv($handle, 1000, $delimiter)) !== FALSE)
		{
			if(!$header)
				$header = $row;
			else
				$data[] = array_combine($header, $row);
		}
		fclose($handle);
	}
	return $data;
}
