#!/usr/bin/env php
## script/test: Run test suite for application. Optionally pass in a path
#              to run specific tests on those files/folders.
<?php
// Go to LORIS root.
chdir(dirname(__FILE__) . '/..');
require('tools/PHP_CLI_Helper.class.inc');

$args = $argv;
if ($argv[0] === 'php') {
    array_shift($args);
}
$test_commands = array();
$files = array();
/* If no file arguments passed, just run all the tests. PHPCS is skipped
 * because it requires a list of files.
 */
if (count($args) <= 1) {
    $test_commands = array(
        // Run linters first as they fail faster than unit tests.
        'npm run lint:php',
        'npm run lint:javascript',
        'vendor/bin/phan',
        'vendor/bin/phpunit --configuration test/phpunit-noCI.xml'
    );
    foreach ($test_commands as $cmd) {
        if (doExec($cmd) === false) {
            die("[-] Test $cmd failed." . PHP_EOL);
        }
    }
    exit(0);
}
// Join individual files with spaces and ignore script name.
array_shift($args);
$files = $args;

$sorted = sortFilesByExtension($files);

// Execute test commands on the appropriate files.
if (count($sorted['js']) > 0) {
    $files_string = implode(' ', $sorted['js']);
    $cmd = 'npm run lint:javascript';
    if (doExec($cmd . ' ' . $files_string) === false) {
        die;
    }
}

if (count($sorted['php']) > 0) {
    // Run linters first as they fail faster than unit tests.
    $test_commands = array(
        'vendor/bin/phpcs --standard=docs/LorisCS.xml',
        'npm run lint:php',
        'vendor/bin/phan',
        'vendor/bin/phpunit --configuration test/phpunit.xml'
    );
    $files_string = implode(' ', $sorted['php']);
    foreach ($test_commands as $cmd) {
        if (doExec($cmd . ' ' . $files_string) === false) {
            die("[-] Test $cmd failed." . PHP_EOL);
        }
    }
}
echo "[+] All tests completed successfully!" . PHP_EOL;

function sortFilesByExtension(array $files)
{
    $sorted = array(
        'php' => array(),
        'js' => array(),
    );

    foreach ($files as $file) {
        if (is_dir($file)) {
            $directory = new RecursiveDirectoryIterator($files[0]);
            // Filter out folders beginning with '.'
            print_r($directory);
            $filter = new DirnameFilter($directory, '/^(?!\.)/');
            // Filter .php and .class.inc files
            $php_filter = new FilenameFilter($filter, '/\.(?:php|class.inc)$/');
            // Filter js files
            $js_filter = new FilenameFilter($filter, '/\.(?:js)/');

            foreach(new RecursiveIteratorIterator($php_filter) as $file) {
                array_push($sorted['php'], $file);
            }
            foreach(new RecursiveIteratorIterator($js_filter) as $file) {
                array_push($sorted['js'], $file);
            }
        } else {
            if (preg_match('/\.(js)$/', $file)) {
                array_push($sorted['js'], $file);
            } else if (preg_match('/\.(?:php|class.inc)$/', $file)) {
                array_push($sorted['php'], $file);
            } else {
                echo "ERROR: $file is neither a js nor a php file." . PHP_EOL;
            }
        }
    }
    return $sorted;
}

/**
 * Small classes used to simplify the directory recursing above.
 */
abstract class FilesystemRegexFilter extends RecursiveRegexIterator {
    protected $regex;
    public function __construct(RecursiveIterator $it, $regex) {
        $this->regex = $regex;
        parent::__construct($it, $regex);
    }
}
/**
 * Filter by filename and regex.
 */
class FilenameFilter extends FilesystemRegexFilter {
    // Filter files against the regex
    public function accept() {
        return ( ! $this->isFile() || preg_match($this->regex, $this->getFilename()));
    }
}
/**
 * Filter by directory name and regex.
 */
class DirnameFilter extends FilesystemRegexFilter {
    // Filter directories against the regex
    public function accept() {
        return ( ! $this->isDir() || preg_match($this->regex, $this->getFilename()));
    }
}
