!function(e){function n(t){if(a[t])return a[t].exports;var r=a[t]={exports:{},id:t,loaded:!1};return e[t].call(r.exports,r,r.exports,n),r.loaded=!0,r.exports}var a={};return n.m=e,n.c=a,n.p="",n(0)}([function(e,n,a){a(1)(a(5))},function(e,n){e.exports=function(e){"undefined"!=typeof execScript?execScript(e):eval.call(null,e)}},,,,function(e,n){e.exports='/* exported RMarkdown */\n\n/**\n * This file contains a React component which renders markdown text into HTML.\n * by way of JSX.\n *\n * Only very basic markdown is supported. In particular:\n * 1. Paragraphs can be delineated with an empty line.\n * 2. **text** or __text__ will bold the text. *text* or _text_ will italicize it.\n * 3. Up to six header levels can be supported by starting a paragraph with (up to 6)\n *    # characters.\n * 4. Links can be added with [text](url)\n *\n * This should be enough to write help documents in Markdown, even without the\n * more complicated features that markdown should support.\n *\n * @author Dave MacFarlane\n * @version 0.0.1\n *\n */\nvar Markdown = React.createClass({\n  displayName: "Markdown",\n\n  propTypes: {\n    content: React.PropTypes.string.isRequired\n  },\n  render: function render() {\n    // Fix stupid-style newlines to be just \\n.\n    var fixedNewlines = this.props.content.replace("\\r\\n", "\\n");\n\n    // 2 newlines in a row mean it\'s a paragraph breaker.\n    var paragraphs = fixedNewlines.split("\\n\\n");\n    var headersRe = /^(#+)\\s+(.+)$/;\n\n    // Do a non-greedy match on text surrounded by ** or __ separately,\n    // because we need to be sure that the end tag is the same as the\n    // start and want the callback to reference the same index\n    var boldRe1 = /(\\*\\*)(.+?)(\\*\\*)/g;\n    var boldRe2 = /(__)(.+?)(__)/g;\n    var boldCallback = function boldCallback(match, start, content, end, offset, val) {\n      return "<b>" + content + "</b>";\n    };\n\n    var italRe1 = /(\\*)(.+?)(\\*)/g;\n    var italRe2 = /(_)(.+?)(_)/g;\n    var italCallback = function italCallback(match, start, content, end, offset, val) {\n      return "<i>" + content + "</i>";\n    };\n\n    var linkRe = /\\[(.+?)\\]\\((.+?)\\)/g;\n    var linkCallback = function linkCallback(match, text, link, offset, val) {\n      return \'<a href="\' + link + \'">\' + text + \'</a>\';\n    };\n    for (var i = 0; i < paragraphs.length; i++) {\n      // For now, assume that there\'s an empty line between\n      // any headers. It\'s not true of strict markdown, but\n      // it\'s true enough to enforce for the help pages.\n      // Technically, a header should also end at the newline,\n      // not at the end of its paragraph too.\n      if (paragraphs[i][0] === \'#\') {\n        var hlevel = 1;\n        paragraphs[i] = paragraphs[i].replace(headersRe, function (match, headerLevel, headerContent, offset, val, hlevel) {\n          hlevel = headerLevel.length;\n          return headerContent;\n        });\n\n        switch (hlevel) {\n          case 6:\n            paragraphs[i] = React.createElement(\n              "h6",\n              null,\n              paragraphs[i]\n            );\n            break;\n\n          case 5:\n            paragraphs[i] = React.createElement(\n              "h5",\n              null,\n              paragraphs[i]\n            );\n            break;\n\n          case 4:\n            paragraphs[i] = React.createElement(\n              "h4",\n              null,\n              paragraphs[i]\n            );\n            break;\n\n          case 3:\n            paragraphs[i] = React.createElement(\n              "h3",\n              null,\n              paragraphs[i]\n            );\n            break;\n\n          case 2:\n            paragraphs[i] = React.createElement(\n              "h2",\n              null,\n              paragraphs[i]\n            );\n            break;\n          case 1:\n          default:\n            paragraphs[i] = React.createElement(\n              "h1",\n              null,\n              paragraphs[i]\n            );\n        }\n      } else {\n        var paramd = paragraphs[i];\n        // Do bold before italics, because otherwise italics will catch\n        // the inner * of the bold.\n        paramd = paramd.replace(boldRe1, boldCallback);\n        paramd = paramd.replace(boldRe2, boldCallback);\n\n        paramd = paramd.replace(italRe1, italCallback);\n        paramd = paramd.replace(italRe2, italCallback);\n\n        paramd = paramd.replace(linkRe, linkCallback);\n        paragraphs[i] = React.createElement("p", { dangerouslySetInnerHTML: { __html: paramd } });\n      }\n    }\n    return React.createElement(\n      "div",\n      null,\n      paragraphs\n    );\n  }\n});\n\nvar RMarkdown = React.createFactory(Markdown);'}]);